---
title: "树"
---

# 二叉树

## 94 二叉树的中序遍历

给定一个二叉树的根节点 root ，返回它的 中序 遍历。

### 递归

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$

```c++
void helper(TreeNode *root, vector<int> &result) {
    if (!root) {
        return;
    }
    helper(root->left, result);
    result.push_back(root->val);
    helper(root->right, result);
}

vector<int> in_order(TreeNode *root) {
    vector<int> result;
    helper(root, result);
    return result;
}
```

### 迭代

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$

```c++
vector<int> in_order(TreeNode *root) {
    std::stack<TreeNode *> s;
    vector<int> result;
    while (root || !s.empty()) {
        while (root) {
            s.push(root);
            root = root->left;
        }
        root = s.top();
        s.pop();
        result.push_back(root->val);
        root = root->right;
    }
    return result;
}
```

### Morris 中序遍历

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$

```c++
vector<int> in_order(TreeNode *root) {
    vector<int> result;
    TreeNode *pre = nullptr;
    while (root) {
        if (root->left) {
            pre = root->left;
            while (pre->right && pre->right != root) {
                pre = pre ->right;
            }
            if (!pre->right) {
                pre->right = root;
                root = root->left;
            } else {
                result.push_back(root->val);
                pre->right = nullptr;
                root = root->right;
            }
        } else {
            result.push_back(root->val);
            root = root->right;
        }
    }
    return result;
}
```

## 98 验证二叉搜索树

给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

- 节点的左子树只包含小于当前节点的数。
- 节点的右子树只包含大于当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

### 递归

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$

```c++
bool helper(TreeNode *root, long long low, long long high) {
    if (!root) {
        return true;
    }

    if (root->val <= low || root->val >= high) {
        return false;
    }
    return helper(root->left, low, root->val) &&
           helper(root->right, root->val, high);
}

bool is_bst(TreeNode *root) {
    return helper(root, LONG_MIN, LONG_MAX);
}
```

### 中序遍历

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$

```c++
bool is_bst(TreeNode *root) {
    std::stack<TreeNode *> s;
    long long pre = LONG_MIN;
    while (!s.empty() || root) {
        while (root) {
            s.push(root);
            root = root->left;
        }
        root = s.top();
        s.pop();
        if (root->val <= pre) {
            return false;
        }
        pre = root->val;
        root = root->right;
    }
    return true;
}
```

## 101 对称二叉树

给定一个二叉树，检查它是否是镜像对称的。

### 迭代法

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$

```c++
bool is_symmetric(TreeNode *root) {
    std::queue<TreeNode *> q;
    if (root) {
        q.push(root->left);
        q.push(root->right);
    }
    while (!q.empty()) {
        TreeNode *l = q.front();
        q.pop();
        TreeNode *r = q.front();
        q.pop();
        if (!l && !r) {
            continue;
        } else if (!l || !r) {
            return false;
        }
        if (l->val != r->val) {
            return false;
        }
        q.push(l->left);
        q.push(r->right);
        q.push(l->right);
        q.push(r->left);
    }
    return true;
}
```

### 递归法

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$

```c++
bool helper(TreeNode *l, TreeNode *r) {
    if (!l && !r) {
        return true;
    } else if (!l || !r) {
        return false;
    }
    if (l->val != r->val) {
        return false;
    } else {
        return helper(l->left, r->right) && helper(l->right, r->left);
    }
}

bool is_symmetric(TreeNode *root) {
    return root ? helper(root->left, root->right) : true;
}
```

## 102 二叉树的层序遍历

给你一个二叉树，请你返回其按 层序遍历 得到的节点值。（即逐层地，从左到右访问所
有节点）。

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$

```c++
vector<vector<int>> level_order(TreeNode *root) {
    std::queue<TreeNode *> q;
    if (root) {
        q.push(root);
    }
    vector<vector<int>> result;
    while (!q.empty()) {
        vector<int> level;
        int s = q.size();
        for (int i = 0; i < s; i++) {
            auto p = q.front();
            q.pop();
            level.push_back(p->val);
            if (p->left) {
                q.push(p->left);
            }
            if (p->right) {
                q.push(p->right);
            }
        }
        result.push_back(level);
    }
    return result;
}
```

## 108 将有序数组转换为二叉搜索树

给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。

高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。

### 二分法

- 时间复杂度：$O(n)$
- 空间复杂度：$O(\log n)$

```c++
TreeNode *helper(vector<int> &nums, int l, int r) {
    if (r - l == 0) {
        return nullptr;
    }
    int m = l + (r - l - 1) / 2;
    TreeNode *root = new TreeNode(nums[m]);
    root->left = helper(nums, l, m);
    root->right = helper(nums, m + 1, r);
    return root;
}

TreeNode *sorted_array_to_bst(vector<int> &nums) {
    return helper(nums, 0, nums.size());
}
```

## 226. 翻转二叉树

翻转一棵二叉树。

```c++
TreeNode *invert_tree(TreeNode *root) {
    if (!root) {
        return root;
    }
    TreeNode *left0 = root->left;
    root->left = invert_tree(root->right);
    root->right = invert_tree(left0);
    return root;
}
```

## 958 二叉树的完全性检验

若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第
h 层所有的结点都连续集中在最左边，这就是完全二叉树。（注：第 h 层可能包含 $1 \sim 2^h$
个节点。）

### 广度优先遍历

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$

```c++
bool is_complete_tree_v2(TreeNode *root) {
    std::queue<TreeNode *> q;
    if (root) {
        q.push(root);
    }
    bool is_pre_end = false;
    while (!q.empty()) {
        auto front = q.front();
        q.pop();
        if ((front->right && !front->left) ||
            (is_pre_end && (front->left || front->right))) {
            return false;
        }
        if (!front->left || !front->right) {
            is_pre_end = true;
        }
        if (front->left) {
            q.push(front->left);
        }
        if (front->right) {
            q.push(front->right);
        }
    }
    return true;
}
```

# 前缀树

## 208 实现 Trie（前缀树）

实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。

示例:

```java
Trie trie = new Trie();

trie.insert("apple");
trie.search("apple");   // 返回 true
trie.search("app");     // 返回 false
trie.startsWith("app"); // 返回 true
trie.insert("app");   
trie.search("app");     // 返回 true
```

说明:

- 你可以假设所有的输入都是由小写字母 a-z 构成的。
- 保证所有输入均为非空字符串。

```c++
class TrieNode {
  public:
    vector<Trie *> next;
    bool is_end;
    TrieNode() : next(26, nullptr), is_end{false} {}
};

class Trie {
  private:
    TrieNode *root;

  public:
    Trie() {
        root = new TrieNode();
    }

    void insert(string word) {
        TrieNode *node = root;
        for (auto c : word) {
            if (!node->next[c - 'a']) {
                node->next[c - 'a'] = new TrieNode();
            }
            node = node->next[c - 'a'];
        }
        node->is_end = true;
    }

    bool search(string word) {
        TrieNode *node = root;
        for (auto c : word) {
            if (!node->next[c - 'a']) {
                return false;
            }
            node = node->next[c - 'a'];
        }
        return node->is_end;
    }

    bool start_with(string prefix) {
        TrieNode *node = root;
        for (auto c : prefix) {
            if (!node->next[c - 'a']) {
                return false;
            }
            node = node->next[c - 'a'];
        }
        return true;
    }
}
```
