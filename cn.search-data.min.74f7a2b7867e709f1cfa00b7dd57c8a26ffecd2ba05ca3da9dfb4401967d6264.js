'use strict',function(){const b={encode:!1,tokenize:function(a){const b=/\W/;let c=a.split(/\s/);return c.flatMap(a=>{return b.test(a)?a.split(''):[a]})}};b.doc={id:'id',field:['title','content'],store:['title','href','section']};const a=FlexSearch.create('balance',b);window.bookSearchIndex=a,a.add({id:0,href:'/note/%E7%BC%96%E7%A8%8B/bash/',title:"Bash",section:"编程",content:"快捷键  表 1: Bash 快捷键  功能 快捷键    将光标移动到行首 Ctrl-a  将光标移动到行尾 Ctrl-e  将光标向前移动一个单词 Alt-f  将光标向后移动一个单词 Alt-b     IO 重定向 将 stderr 和 stdout 追加到同一个文件：\ncmd \u0026gt;\u0026gt;file.txt 2\u0026gt;\u0026amp;1 变量替换（Parameter Substitution）  表 2: Bash 变量替换  语法 含义    ${#var} String length  ${var#Pattern} 从 $var 前面移除最短匹配 $Pattern 的部分  ${var##Pattern} 从 $var 前面移除最长匹配 $Pattern 的部分  ${var%Pattern} 从 $var 后面移除最短匹配 $Pattern 的部分  ${var%%Pattern} 从 $var 后面移除最长匹配 $Pattern 的部分     例子 $ test_file_path=\u0026quot;/a/b.c\u0026quot; $ echo ${test_file_path##*/} b.c Heredoc cat \u0026lt;\u0026lt;END hello world END 备忘单 https://devhints.io/bash。\n颜色[1]  表 3: 终端颜色转义码列表  颜色 转义码    正常 \\e[0m  红色 \\e[31m  绿色 \\e[32m     状态码[2]  表 4: 状态码  状态码 含义    1 其他错误  2 使用 shell 内建命令出错  126 命令无法执行  127 命令未找到  128 无效的参数  130 取消     参考文献 [1] FLOZZ. Bash tips: Colors and formatting (ANSI/VT100 Control sequences)[EB/OL]([日期不详]). https://misc.flogisoft.com/bash/tip_colors_and_formatting.\n [2] ORNBO G. Linux and Unix exit code tutorial with examples[EB/OL](2019–11–16). https://shapeshed.com/unix-exit-codes/.\n  目录  快捷键 IO 重定向 变量替换（Parameter Substitution）  例子  Heredoc 备忘单 颜色[1] 状态码[2] 参考文献   "}),a.add({id:1,href:'/note/%E7%BC%96%E7%A8%8B/c++/',title:"C++",section:"编程",content:'开发环境 cmake 安装 CMAKE_VERSION=3.19.1 curl -LO \u0026quot;https://github.com/Kitware/CMake/releases/download/v$CMAKE_VERSION/cmake-$CMAKE_VERSION-Linux-x86_64.sh\u0026quot; sudo sh ./cmake-$CMAKE_VERSION-Linux-x86_64.sh --skip-license --prefix=/usr/local 教程  https://cliutils.gitlab.io/modern-cmake/  工程目录结构[1] project ├── CMakeLists.txt ├── compile_commands.json -\u0026gt; build/compile_commands.json ├── include │ └── CLI │ ├── App.hpp │ ├── Config.hpp │ └── Formatter.hpp ├── README.md └── src  ├── CMakeLists.txt  └── main.cpp clangd[2] cd build cmake .. -DCMAKE_EXPORT_COMPILE_COMMANDS=1 cd .. ln -s build/compile_commands.json compile_commands.json 代码风格 文件后缀  源代码：cpp  命名规范  Type names  名词 TextFileReader  Function names  动词 openFile    请参考：\n https://llvm.org/docs/CodingStandards.html#llvm-coding-standards https://google.github.io/styleguide/cppguide.html   教程  https://isocpp.org/get-started  最佳实践  表 1: 最佳实践  场景 最佳实践 不好的实践    初始化 {} ()  空指针 nullptr NULL 或者 0  字符串拼接 string nametext = "Your name is" + name;   int -\u0026gt; string string s = std::to_string(42);[3]      vector 常用方法  表 2: vector 常用方法  代码 含义    std::vector\u0026lt;int\u0026gt; vector1(length, 0); 初始化为 0  size() 返回元素个数  push_back(val) 在末尾添加元素 val  pop_back() 删除最后一个元素  std::find(v.begin(), v.end(), val) != v.end() v 包含 val     set 常用方法  表 3: set 常用方法  代码 含义    s.find(val) != s.end() s 包含 val     参考文献 [1] SCHREINER H. How to structure your project[J/OL]. [日期不详].. https://cliutils.gitlab.io/modern-cmake/chapters/basics/structure.html.\n [2] LLVM. Getting started[J/OL]. [日期不详].. https://clangd.llvm.org/installation.html.\n [3] M M. Easiest way to convert int to string in C++[EB/OL](2011–04–08). https://stackoverflow.com/a/5591169/13200985.\n  目录  开发环境  cmake  安装 教程  工程目录结构[1] clangd[2]  代码风格  文件后缀 命名规范  教程 最佳实践 vector  常用方法  set  常用方法  参考文献   '}),a.add({id:2,href:'/note/%E7%BC%96%E7%A8%8B/css/',title:"CSS",section:"编程",content:"selector  表 1: CSS selector  例子 含义    div \u0026gt; p 父元素为 \u0026lt;div\u0026gt; 的所有 \u0026lt;p\u0026gt; 元素     对齐 # 靠右对齐 text-align: right; width[1]  默认值：auto  参考文献 [1] W3SCHOOLS. CSS width Property[EB/OL]([日期不详]). https://www.w3schools.com/cssref/pr_dim_width.asp.\n  目录  selector 对齐 width[1] 参考文献   "}),a.add({id:3,href:'/note/%E7%BC%96%E7%A8%8B/dhall/',title:"Dhall",section:"编程",content:"安装  表 1: Dhall 安装命令  操作系统 命令    Arch Linux sudo pacman -S dhall     目录  安装   "}),a.add({id:4,href:'/note/%E7%BC%96%E7%A8%8B/fish-shell/',title:"fish-shell",section:"编程",content:"语法 变量 表示 用 {$WORD}s 将变量与文本区分开。\n赋值 set a b find find . -type f -exec echo \u0026#39;{}\u0026#39; \\;  括号需要加引号[1]。\n [1] CHAZELAS S. find -exec not working in fish[EB/OL](2016–08–04). https://unix.stackexchange.com/a/301232.\n  目录  语法  变量  表示 赋值   find   "}),a.add({id:5,href:'/note/%E7%BC%96%E7%A8%8B/flutter/',title:"Flutter",section:"编程",content:"Dart 运算符  表 1: Dart 运算符  符号 含义    ?? if null[1]     合并数组 var newList = [...list1, ...list2, ...list3]; Flutter 联网权限[2] \u0026lt;uses-permissionandroid:name=\u0026quot;android.permission.INTERNET\u0026quot; /\u0026gt; 开发 Android 手机打开 USB 调试 请参考 https://jingyan.baidu.com/article/91f5db1b1d51be1c7e05e35f.html。\n编译 flutter build apk --split-per-abi --verbose 安装  把手机连到电脑上。\n flutter install 语法 switch var command = \u0026#39;OPEN\u0026#39;; switch (command) { case \u0026#39;CLOSED\u0026#39;: executeClosed(); break; case \u0026#39;PENDING\u0026#39;: executePending(); break; case \u0026#39;APPROVED\u0026#39;: executeApproved(); break; case \u0026#39;DENIED\u0026#39;: executeDenied(); break; case \u0026#39;OPEN\u0026#39;: executeOpen(); break; default: executeUnknown(); } 参考文献 [1] SURAGCH. What are the ?? double question marks in Dart?[EB/OL](2019–01–04). https://stackoverflow.com/a/54031805/13200985.\n [2] MHSMITH. What permission do I need to access Internet from an Android application?[EB/OL](2020–04–16). https://stackoverflow.com/a/2378619/13200985.\n  目录  Dart  运算符 合并数组  Flutter  联网权限[2] 开发  Android 手机打开 USB 调试 编译 安装  语法  switch   参考文献   "}),a.add({id:6,href:'/note/%E5%B7%A5%E5%85%B7/git/',title:"Git",section:"工具",content:"常见操作 恢复文件[1] # this restores the file status in the index git reset -- \u0026lt;file\u0026gt; # then check out a copy from the index git checkout -- \u0026lt;file\u0026gt; diff 安装 delta  表 1: delta 安装命令  操作系统 命令    Arch Linux yay -S git-delta  Nix nix-env -iA nixpkgs.gitAndTools.delta     Git Submodule 下载 submodule git submodule update --init --force --recursive --depth=1 更新 url git submodule set-url themes/book https://github.com/alex-shpak/hugo-book.git 删除 submodule[2] git rm \u0026lt;submodule path\u0026gt; 参考文献 [1] TWALBERG. Unstage a deleted file in git[EB/OL](2012–03–06). https://stackoverflow.com/a/9591612/13200985.\n [2] GIT. Git - gitsubmodules Documentation[EB/OL]([日期不详]). https://git-scm.com/docs/gitsubmodules.\n  目录  常见操作  恢复文件[1]  diff  安装 delta  Git Submodule  下载 submodule 更新 url 删除 submodule[2]  参考文献   "}),a.add({id:7,href:'/note/%E7%BC%96%E7%A8%8B/golang/',title:"Golang",section:"编程",content:"time 时间格式  2006-01-02 15:04:05 -0700  目录  time  时间格式    "}),a.add({id:8,href:'/note/NLP/GPT-2/',title:"GPT-2",section:"NLP",content:"Auto-Regression[1]  图 1: Auto-Regression  每个记号产生后加入输入序列。\nMasked Self-Attention[1]  图 2: Masked Self-Attention   图 3: Masked Self-Attention 具体例子  Q、K 和 V  图 4: Self-Attention 的 Q、K 与 V  输出  图 5: 输出  参考文献 [1] ALAMMAR J. The Illustrated GPT-2[EB/OL](2019–08–12). http://jalammar.github.io/illustrated-gpt2/.\n  目录  Auto-Regression[1] Masked Self-Attention[1] Q、K 和 V 输出 参考文献   "}),a.add({id:9,href:'/note/%E7%BC%96%E7%A8%8B/html/',title:"HTML",section:"编程",content:"Language Code[1]  表 1: ISO 639-1 Language Codes  Language ISO Code    Chinese (Simplified) zh-Hans     参考文献 [1] W3SCHOOLS. HTML Language Code Reference[EB/OL]([日期不详]). https://www.w3schools.com/tags/ref_language_codes.asp.\n  目录  Language Code[1] 参考文献   "}),a.add({id:10,href:'/note/CS/http/',title:"HTTP",section:"CS",content:"URL vs URI[1] URL 用于定位，URI 用于标识。\nhttpie 安装 httpie  表 1: httpie 安装命令  操作系统 命令    Nix nix-env -iA nixpkgs.httpie     用法 Query Parameters param==value 状态码  表 2: HTTP 状态码[2]  状态码 含义    401 认证失败  403 已认证，但没有权限     NGINX 编译安装  推荐安装 mainline 版本[3]。\n # Environment variables NGINX_VERSION=1.17.9 PCRE_VESION=8.44 ZLIB_VERSION=1.2.11 NGINX_UPLOAD_MODULE_VERSION=2.3.0  # Download source code curl -LO https://nginx.org/download/nginx-$NGINX_VERSION.tar.gz \\  \u0026amp;\u0026amp; tar -xzvf nginx-$NGINX_VERSION.tar.gz curl -LO https://ftp.pcre.org/pub/pcre/pcre-$PCRE_VERSION.tar.gz \\  \u0026amp;\u0026amp; tar -xzvf pcre-$PCRE_VERSION.tar.gz curl -LO https://www.zlib.net/zlib-$ZLIB_VERSION.tar.gz \\  \u0026amp;\u0026amp; tar -xzvf zlib-$ZLIB_VERSION.tar.gz curl -o nginx-upload-module-$NGINX_UPLOAD_MODULE_VERSION.tar.gz \\  -L https://github.com/vkholodkov/nginx-upload-module/archive/$NGINX_UPLOAD_MODULE_VERSION.tar.gz \\  \u0026amp;\u0026amp; tar -xzvf nginx-upload-module-$NGINX_UPLOAD_MODULE_VERSION.tar.gz  # Compile and install cd nginx-$NGINX_VERSION ./configure \\  --sbin-path=/usr/sbin/nginx \\  --conf-path=/etc/nginx/nginx.conf \\  --pid-path=/run/nginx.pid \\  --with-http_ssl_module \\  --with-http_stub_status_module \\  --with-pcre=../pcre-$PCRE_VERSION \\  --with-zlib=../zlib-$ZLIB_VERSION \\  --add-module=../nginx-upload-module-$NGINX_UPLOAD_MODULE_VERSION make make install websocket http { map $http_upgrade $connection_upgrade { default upgrade; \u0026#39;\u0026#39; close; } server { ... location /chat/ { proxy_pass http://backend; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection $connection_upgrade; } } } nginx-upload-module 配置例子 server { location /api/upload/v1 { auth_basic \u0026quot;Administrator\u0026#39;s Area\u0026quot;; auth_basic_user_file /etc/apache2/.htpasswd; upload_pass @uploadServer; upload_store /tmp/nginx; upload_store_access user:r; # Set specified fields in request body upload_set_form_field $upload_field_name.name \u0026quot;$upload_file_name\u0026quot;; upload_set_form_field $upload_field_name.content_type \u0026quot;$upload_content_type\u0026quot;; upload_set_form_field $upload_field_name.path \u0026quot;$upload_tmp_path\u0026quot;; upload_pass_form_field \u0026quot;^submit$|^targetFilePaths$\u0026quot;; # Inform backend about hash and size of a file upload_aggregate_form_field \u0026quot;$upload_field_name.sha1\u0026quot; \u0026quot;$upload_file_sha1\u0026quot;; upload_aggregate_form_field \u0026quot;$upload_field_name.size\u0026quot; \u0026quot;$upload_file_size\u0026quot;; upload_cleanup 400 404 499 500-505; } location @uploadServer { proxy_pass http://upload-server; } location /upload-files/ { alias /var/www/html/upload-files/; try_files $uri $uri/ =404; autoindex on; autoindex_exact_size off; autoindex_localtime on; } } curl 上传时显示进度条[4] curl ... | tee /dev/null urlencode 参数[5] curl ... --data-urlencode \u0026quot;paramName=value\u0026quot; 得到响应中的 Location header[6] curl \u0026#39;http://httpbin.org/redirect-to?url=http:/\\example.com\u0026#39; -si | grep -oP \u0026#39;Location: \\K.*\u0026#39; Open API redoc 安装 yarn global add redoc-cli 生成 API 文档 redoc-cli bundle \u0026lt;openapi_file_path\u0026gt; 语法  表 3: Open API 数据类型  type format 含义    number float float  number double double     API seafile  上传文件：https://download.seafile.com/published/web-api/v2.1/file-upload.md Web API: https://seafile.gitbook.io/seafile-server-manual/developing/web-api  参考文献 [1] PATE R. What is the difference between a URI, a URL and a URN?[EB/OL](2009–12–31). https://stackoverflow.com/a/1984225.\n [2] JPREDDY. 403 Forbidden vs 401 Unauthorized HTTP responses[EB/OL](2011–08–04). https://stackoverflow.com/a/6937030/13200985.\n [3] NGINX. NGINX 1.6 and 1.7 Released[EB/OL](2014–04–24). https://www.nginx.com/blog/nginx-1-6-1-7-released/#Which-Version-Should-I-Use.\n [4] STACKOVERFLOW. cURL: How to display progress information while uploading?[EB/OL](2012–04–02). https://stackoverflow.com/questions/9973056/curl-how-to-display-progress-information-while-uploading/41860083.\n [5] STACKOVERFLOW. How to urlencode data for curl command?[EB/OL](2017–08–14). https://stackoverflow.com/questions/296536/how-to-urlencode-data-for-curl-command.\n [6] RANDOMIR. [EB/OL](2017–09–30). https://stackoverflow.com/a/46507651.\n  目录  URL vs URI[1] httpie  安装 httpie 用法  Query Parameters   状态码 NGINX  编译安装 websocket nginx-upload-module  配置例子   curl  上传时显示进度条[4] urlencode 参数[5] 得到响应中的 Location header[6]  Open API  redoc  安装 生成 API 文档  语法  API  seafile  参考文献   "}),a.add({id:11,href:'/note/%E5%B7%A5%E5%85%B7/ipad/',title:"iPad",section:"工具",content:"多任务 分屏 如何调整分屏浏览[1]：\n 要让两个应用均匀分布在屏幕上，请将应用分隔条拖移到屏幕中央； 要将分屏浏览转为侧拉，请从应用顶部向下轻扫； 要关闭分屏浏览，请将应用分隔条从想要关闭的应用上方拖过。  参考文献 [1] APPLE. 在 iPad 上使用多任务处理功能[EB/OL]([日期不详]). https://support.apple.com/zh-cn/HT207582.\n  目录  多任务  分屏  参考文献   "}),a.add({id:12,href:'/note/%E7%BC%96%E7%A8%8B/js/',title:"JavaScript",section:"编程",content:"字符串拼接[1] 要使用 + 而不是 string.concat()。\nArray flatMap[2] 等价于先 map() 再 flat()。\nlet arr1 = [1, 2, 3, 4];  arr1.map(x =\u0026gt; [x * 2]);  // [[2], [4], [6], [8]]  arr1.flatMap(x =\u0026gt; [x * 2]); // [2, 4, 6, 8]  // only one level is flattened arr1.flatMap(x =\u0026gt; [[x * 2]]); // [[2], [4], [6], [8]] 正则表达式  表 1: JavaScript 常用正则表达式    代码 含义    \\s 单个空白字符，等价于 [ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]  \\W 非基本拉丁字母，等价于 [^A-Za-z0-9_]     导航到新地址[3] window.location.href = \u0026#39;...\u0026#39;; 得到链接的 href 属性[4] document.getElementById(\u0026quot;aaa\u0026quot;).href; 寻找元素 var matches = document.querySelectorAll(\u0026quot;p\u0026quot;); 移动元素[5] newParent.appendChild(element); 改变元素的类[6] document.getElementById(\u0026quot;MyElement\u0026quot;).classList.add(\u0026#39;MyClass\u0026#39;);  document.getElementById(\u0026quot;MyElement\u0026quot;).classList.remove(\u0026#39;MyClass\u0026#39;);  if ( document.getElementById(\u0026quot;MyElement\u0026quot;).classList.contains(\u0026#39;MyClass\u0026#39;) )  document.getElementById(\u0026quot;MyElement\u0026quot;).classList.toggle(\u0026#39;MyClass\u0026#39;); 参考文献 [1] LAKTAK. JS strings 《+》 vs concat method [duplicate][EB/OL](2013–04–20). https://stackoverflow.com/a/16124072.\n [2] MDN. Array.prototype.flatMap()[EB/OL]([日期不详]). https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap.\n [3] STACKOVERFLOW. How to get the browser to navigate to URL in JavaScript [duplicate][EB/OL](2009–08–04). https://stackoverflow.com/a/1226718.\n [4] STACKOVERFLOW. Get local href value from anchor (a) tag[EB/OL](2013–03–15). https://stackoverflow.com/a/15439946.\n [5] STACKOVERFLOW. How to move all HTML element children to another parent using JavaScript?[EB/OL](2014–01–03). https://stackoverflow.com/questions/20910147/how-to-move-all-html-element-children-to-another-parent-using-javascript.\n [6] BOUGHTON P. How can I change an element’s class with JavaScript?[EB/OL](2008–10–12). https://stackoverflow.com/a/196038.\n  目录  字符串拼接[1] Array  flatMap[2]  正则表达式 导航到新地址[3] 得到链接的 href 属性[4] 寻找元素 移动元素[5] 改变元素的类[6] 参考文献   "}),a.add({id:13,href:'/note/CS/linux/',title:"Linux",section:"CS",content:"发行版 Arch Linux 清除缓存 sudo paccache -rk0 Ubuntu add-apt-repository: command not found sudo apt install software-properties-common nix Virtual Box sudo pacman -S xf86-video-vmware 挂载 samba  表 1: samba 组件安装命令  操作系统 命令    Ubuntu sudo apt install cifs-utils     查看目录 broot 安装 broot  表 2: broot 安装命令  操作系统 命令    Arch Linux sudo pacman -S broot     Core Pattern # ulimit -c unlimited # sysctl -w kernel.core_pattern=core.%p # sysctl --system # 使更改生效 Sed sed \u0026#39;s/Hello/Hi/g\u0026#39; \u0026lt;file_name\u0026gt; \u0026gt; file 壁纸 nix-env -iA nixpkgs.variety 常用命令 合并文件 cat * \u0026gt; merged-file 把 windows 的 CR+LF 变为 Linux 的 LF dos2unix myfile.txt 目录  发行版  Arch Linux  清除缓存  Ubuntu  add-apt-repository: command not found  nix  Virtual Box 挂载  samba  查看目录  broot  安装 broot   Core Pattern Sed 壁纸 常用命令  合并文件 把 windows 的 CR+LF 变为 Linux 的 LF    "}),a.add({id:14,href:'/note/%E5%B7%A5%E5%85%B7/Linux/',title:"Linux",section:"工具",content:"窗口管理器 i3  表 1: i3 常见命令  命令 功能    i3-msg exit 登出     i3lockr https://github.com/owenthewizard/i3lockr\n手册 tldr  表 2: tldr 安装命令  操作系统 命令    Arch Linux sudo pacman -S tldr  其他 yarn global add tldr     rsync 带进度条的复制 rsync --info=progress2 -rh ${source} ${dest} 指定私钥文件[1] rsync -Pav -e \u0026quot;ssh -i $HOME/.ssh/somekey\u0026quot; username@hostname:/from/dir/ /to/dir/ 终端 tmux # 列出会话 tmux ls  # 创建新会话 tmux new -s myname  # 连接会话 tmux a -t myname 硬盘  https://github.com/bootandy/dust  du[2] du -sh /a/* | sort -rh | head -5 jq 过滤[3] select(.name == \u0026quot;TAG\u0026quot;) Print strings without quotes[4] jq --raw-output CPU cat /proc/cpuinfo 参考文献 [1] GARTHWAITE D. Specify identity file with rsync[EB/OL](2014–05–01). https://unix.stackexchange.com/a/127355.\n [2] KUMAR S. How to Find Out Top Directories and Files (Disk Space) in Linux[EB/OL](2016–01–16). https://www.tecmint.com/find-top-large-directories-and-files-sizes-in-linux/.\n [3] STEDOLAN. Cookbook[EB/OL](2019–10–05). https://github.com/stedolan/jq/wiki/Cookbook.\n [4] GITHUB. Print strings without quotes[EB/OL](2013–12–20). https://github.com/stedolan/jq/issues/250.\n  目录  窗口管理器  i3 i3lockr  手册  tldr  rsync  带进度条的复制 指定私钥文件[1]  终端  tmux  硬盘  du[2]  jq  过滤[3] Print strings without quotes[4]  CPU 参考文献   "}),a.add({id:15,href:'/note/NLP/LSTM_GRU/',title:"LSTM 与 GRU",section:"NLP",content:" 请参考 https://towardsdatascience.com/illustrated-guide-to-lstms-and-gru-s-a-step-by-step-explanation-44e9eb85bf21。\n LSTM 请参考 https://colah.github.io/posts/2015-08-Understanding-LSTMs/。\nForget gate:\n\\[ f_t = \\sigma(W_f \\cdot [h_{t-1}, x_t] + b_f) \\qquad(1)\\]\nInput gate:\n\\[ i_t = \\sigma(W_i \\cdot [h_{t-1}, x_t] + b_i) \\qquad(2)\\]\nCell state:\n\\[ \\begin{align} \\tilde{C}_t \u0026amp;= \\tanh(W_C \\cdot [h_{t-1}, x_t] + b_C) \\\\ C_t \u0026amp;= f_t \\odot C_{t-1} + i_t \\odot \\tilde{C}_t \\end{align} \\qquad(3)\\]\nOutput:\n\\[ \\begin{align} o_t \u0026amp;= \\sigma(W_o \\cdot [h_{t-1}, x_t] + b_o) \\\\ h_t \u0026amp;= o_t \\odot \\tanh(C_t) \\end{align} \\qquad(4)\\]\nGRU[1,2] Reset Gate:\n\\[\\v{r}_t = \\sigma(\\m{W}^r\\v{x}_t + \\m{U}^r\\v{h}_{t-1} + \\v{b}^r)\\qquad(5)\\]\nUpdate Gate:\n\\[\\v{u}_t = \\sigma(\\m{W}^u\\v{x}_t + \\m{U}^u\\v{h}_{t-1} + \\v{b}^u)\\qquad(6)\\]\nOutput:\n\\[ \\begin{align} \\tilde{\\v{h}}_t \u0026amp;= \\tanh(\\m{W}^h\\v{x}_t + \\v{r}_t \\odot \\m{U}^h_{t-1}\\v{h}_{t-1} + \\v{b}^h) \\\\ \\v{h}_t \u0026amp;= \\v{u}_t \\odot \\tilde{h}_t + (1-\\v{u}_t) \\odot \\v{h}_{t-1} \\end{align} \\qquad(7)\\]\n参考文献 [1] CHO K, VAN MERRIËNBOER B, GULCEHRE C, 等. Learning phrase representations using RNN encoder-decoder for statistical machine translation[J]. arXiv preprint arXiv:1406.1078, 2014.\n [2] ZHOU G, MOU N, FAN Y, 等. Deep interest evolution network for click-through rate prediction[C]//Proceedings of the AAAI conference on artificial intelligence..\n  目录  LSTM GRU[1,2] 参考文献   "}),a.add({id:16,href:'/note/CS/oauth2/',title:"OAuth 2",section:"CS",content:"教程  https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2  目录  教程   "}),a.add({id:17,href:'/note/%E7%BC%96%E7%A8%8B/pandoc/',title:"Pandoc",section:"编程",content:"引用  在方括号里 分号分隔  [@smith04; @doe99] 脚注 Here is a footnote reference,[^1] and another.[^longnote] [^1]: Here is the footnote. [^longnote]: Here\u0026#39;s one with multiple blocks. Subsequent paragraphs are indented to show that they belong to the previous footnote. { some.code } The whole paragraph can be indented, or just the first line. In this way, multi-paragraph footnotes work like multi-paragraph list items. This paragraph won\u0026#39;t be part of the note, because it isn\u0026#39;t indented. 数学  表 1: 数学语法  类别 语法    行内公式 $\\alpha$  行间公式 $$\\alpha = 1$$     Extension  +EXTENSION 启用 -EXTENSION 禁用  emoji emoji 列表请参考 https://github.com/ikatyang/emoji-cheat-sheet。\n目录  引用 脚注 数学 Extension  emoji    "}),a.add({id:18,href:'/note/%E7%BC%96%E7%A8%8B/PowerShell/',title:"PowerShell",section:"编程",content:"语法 别名 Set-Alias -Name br -Value broot 代理 netsh winhttp show proxy # 显示当前代理 netsh winhttp set proxy \u0026quot;127.0.0.1:3128\u0026quot; # 设置代理 netsh winhttp reset proxy # 重置代理 目录  语法  别名 代理    "}),a.add({id:19,href:'/note/%E7%BC%96%E7%A8%8B/python/',title:"Python",section:"编程",content:"开发环境 miniconda 从 https://docs.conda.io/en/latest/miniconda.html 下载最新版本。\n格式化 pip install black 内建函数[1] 数据类型  表 1: Python 数据类型  数据类型 含义    str 字符串     运算符  表 2: Python 运算符  运算符 含义 例子    ** 幂 2**3 == 8     字典[2] 遍历 list 并获取 index[3] for idx, val in enumerate(ints):  print(idx, val) 遍历字典 \u0026gt;\u0026gt;\u0026gt; knights = {\u0026#39;gallahad\u0026#39;: \u0026#39;the pure\u0026#39;, \u0026#39;robin\u0026#39;: \u0026#39;the brave\u0026#39;} \u0026gt;\u0026gt;\u0026gt; for k, v in knights.items(): ... print(k, v) ... gallahad the pure robin the brave 键是否存在[4] d = {\u0026quot;key1\u0026quot;: 10, \u0026quot;key2\u0026quot;: 23}  if \u0026quot;key1\u0026quot; in d:  print(\u0026quot;this will execute\u0026quot;)  if \u0026quot;nonexistent key\u0026quot; in d:  print(\u0026quot;this will not\u0026quot;) 合并字典[5] z = {**x, **y} += x += y # x = x + y open  表 3: 打开文件模式说明[6]  mode-string truncate? create? what’s allowed    r no no reading (only)  w yes yes writing (only)  a no yes writing (only), auto-appends  r+ no no read and write  w+ yes yes read and write  a+ no yes read and (auto-appending) write     str 字符串复制 \u0026#39;-\u0026#39; * 3 分割[7] \u0026gt;\u0026gt;\u0026gt; \u0026#39;1,2,3\u0026#39;.split(\u0026#39;,\u0026#39;) [\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;] \u0026gt;\u0026gt;\u0026gt; \u0026#39;1,2,3\u0026#39;.split(\u0026#39;,\u0026#39;, maxsplit=1) [\u0026#39;1\u0026#39;, \u0026#39;2,3\u0026#39;] \u0026gt;\u0026gt;\u0026gt; \u0026#39;1,2,,3,\u0026#39;.split(\u0026#39;,\u0026#39;) [\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;\u0026#39;] 函数式编程 partial 大致等价于：\ndef partial(func, /, *args, **keywords):  def newfunc(*fargs, **fkeywords):  newkeywords = {**keywords, **fkeywords}  return func(*args, *fargs, **newkeywords)  newfunc.func = func  newfunc.args = args  newfunc.keywords = keywords  return newfunc property 定义属性，默认只读。\nclass Parrot:  def __init__(self):  self._voltage = 100000   @property  def voltage(self):  \u0026quot;\u0026quot;\u0026quot;Get the current voltage.\u0026quot;\u0026quot;\u0026quot;  return self._voltage super class C(B):  def method(self, arg):  super().method(arg) # This does the same thing as:  # super(C, self).method(arg) classmethod 带 cls 的类方法。\nclass C:  @classmethod  def f(cls, arg1, arg2, ...): ... 三元操作符[8] a if condition else b 迭代器 找到第一个符合条件的元素[9] next(obj for obj in objs if obj.val==5) 计算文件的行数[10] row_count = sum(1 for row in file_object) FAQ Python3: UnicodeEncodeError: ‘ascii’ codec can’t encode character[11] PYTHONIOENCODING=utf-8 python3 script.py numpy import numpy as np 数据类型[12]  表 4: NumPy 数据类型  NumPy 类型 C 类型 含义    np.float64 double 双精度浮点数     算术平均 \u0026gt;\u0026gt;\u0026gt; a = np.array([[1, 2], [3, 4]]) \u0026gt;\u0026gt;\u0026gt; np.mean(a) 2.5 \u0026gt;\u0026gt;\u0026gt; np.mean(a, axis=0) array([2., 3.]) \u0026gt;\u0026gt;\u0026gt; np.mean(a, axis=1) array([1.5, 3.5]) 右乘列向量 \\[\\m{A}\\v{x}\\qquad(1)\\]\nnp.dot(A, x) 竖向堆积 \u0026gt;\u0026gt;\u0026gt; a = np.array([1, 2, 3]) \u0026gt;\u0026gt;\u0026gt; b = np.array([2, 3, 4]) \u0026gt;\u0026gt;\u0026gt; np.vstack((a,b)) array([[1, 2, 3],  [2, 3, 4]]) 范数[13] \\[\\lVert\\v{x}\\rVert_2 = \\left(\\sum_i \\lvert x_i\\rvert^2\\right)^{\\frac{1}{2}}\\qquad(2)\\]\n\u0026gt;\u0026gt;\u0026gt; np.linalg.norm([3, 4]) 5.0 奇异值分解 \\[\\m{A} = \\m{U}\\m{D}\\T{\\m{V}}\\qquad(3)\\]\nU, d, Vt = np.linalg.svd(A) # U @ np.diag(d) @ Vt == A numpy.any 测试某个轴上是否有一个元素为真。\nnumpy.arccos cos 的逆运算。\n\u0026gt;\u0026gt;\u0026gt; np.arccos([1, -1]) array([ 0. , 3.14159265]) numpy.arctan2 \u0026gt;\u0026gt;\u0026gt; x = np.array([-1, +1, +1, -1]) \u0026gt;\u0026gt;\u0026gt; y = np.array([-1, -1, +1, +1]) \u0026gt;\u0026gt;\u0026gt; np.arctan2(y, x) * 180 / np.pi array([-135., -45., 45., 135.]) numpy.clip 等价于 np.minimum(a_max, np.maximum(a, a_min))。\n\u0026gt;\u0026gt;\u0026gt; a = np.arange(10) \u0026gt;\u0026gt;\u0026gt; np.clip(a, 1, 8) array([1, 1, 2, 3, 4, 5, 6, 7, 8, 8]) numpy.deg2rad 角度 -\u0026gt; 弧度：\n\u0026gt;\u0026gt;\u0026gt; np.deg2rad(180) 3.1415926535897931 numpy.degrees 弧度 -\u0026gt; 角度：\n\u0026gt;\u0026gt;\u0026gt; rad = np.arange(12.)*np.pi/6 \u0026gt;\u0026gt;\u0026gt; np.degrees(rad) array([ 0., 30., 60., 90., 120., 150., 180., 210., 240.,  270., 300., 330.]) numpy.zeros 初始化数组。\n\u0026gt;\u0026gt;\u0026gt; np.zeros(5) array([ 0., 0., 0., 0., 0.])  \u0026gt;\u0026gt;\u0026gt; np.zeros((2, 1)) array([[ 0.],  [ 0.]]) pandas join   方法 含义    DataFrame.join() 按 index join  DataFrame.merge() 按 on join    pytorch RNN   函数 用途    pad_packed_sequence 为变长序列填充 0  pack_padded_sequence 把填充过 0 的序列变成变长序列    tqdm 安装 pip install tqdm 基于迭代器 from tqdm import tqdm from time import sleep  text = \u0026quot;\u0026quot; for char in tqdm([\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;, \u0026quot;d\u0026quot;], desc=\u0026#39;demo\u0026#39;, total=4):  sleep(0.25)  text = text + char Pillow 图像大小限制[14] PIL.Image.MAX_IMAGE_PIXELS = 933120000 常用函数 def upper_first_char(str):  return \u0026#39;{}{}\u0026#39;.format(str[0].upper(), str[1:]) anaconda 卸载[15] rm -rf ~/anaconda3 参考文献 [1] PYTHON.ORG. Built-in Functions[EB/OL]([日期不详]). https://docs.python.org/3/library/functions.html#built-in-functions.\n [2] PYTHON.ORG. Looping Techniques[EB/OL]([日期不详]). https://docs.python.org/3/tutorial/datastructures.html#looping-techniques.\n [3] HORDECKI M. Accessing the index in ’for’ loops?[EB/OL](2009–02–06). https://stackoverflow.com/a/522578.\n [4] B. C. Check if a given key already exists in a dictionary[EB/OL](2009–10–21). https://stackoverflow.com/a/1602964.\n [5] HALL A. How do I merge two dictionaries in a single expression?[EB/OL](2011–11–10). https://stackoverflow.com/a/26853961.\n [6] TOREK. Open file for reading and writing with truncate[EB/OL](2015–11–01). https://stackoverflow.com/a/33466886.\n [7] PYTHON. str.split(sep=None, maxsplit=-1)[EB/OL]([日期不详]). https://docs.python.org/3/library/stdtypes.html#str.split.\n [8] VRSALOVIC V. Does Python have a ternary conditional operator?[EB/OL](2020–04–20). https://stackoverflow.com/a/394814/13200985.\n [9] EUMIRO. find first sequence item that matches a criterion[EB/OL](2012–03–26). https://stackoverflow.com/a/9868665/13200985.\n [10] PIETERS M. Count how many lines are in a CSV Python?[EB/OL](2013–04–19). https://stackoverflow.com/a/16108605/13200985.\n [11] MARKHOR. Python3: UnicodeEncodeError: ’ascii’ codec can’t encode character ’’[EB/OL](2016–12–19). https://stackoverflow.com/a/41223807/13200985.\n [12] SCIPY. Data types[EB/OL]([日期不详]). https://docs.scipy.org/doc/numpy/user/basics.types.html.\n [13] SCIPY.ORG. numpy.linalg.norm[EB/OL]([日期不详]). https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.norm.html.\n [14] ALFE. Pillow in Python won’t let me open image (《exceeds limit》)[EB/OL](2018–07–03). https://stackoverflow.com/a/51152514.\n [15] ANACONDA. Uninstalling Anaconda[EB/OL]([日期不详]). https://docs.anaconda.com/anaconda/install/uninstall/#uninstalling-anaconda.\n  目录  开发环境  miniconda 格式化  内建函数[1]  数据类型 运算符 字典[2]  遍历 list 并获取 index[3] 遍历字典 键是否存在[4] 合并字典[5]  += open str  字符串复制 分割[7]  函数式编程  partial  property super classmethod 三元操作符[8] 迭代器  找到第一个符合条件的元素[9] 计算文件的行数[10]  FAQ  Python3: UnicodeEncodeError: ‘ascii’ codec can’t encode character[11]   numpy  数据类型[12] 算术平均 右乘列向量 竖向堆积 范数[13] 奇异值分解 numpy.any numpy.arccos numpy.arctan2 numpy.clip numpy.deg2rad numpy.degrees numpy.zeros  pandas  join  pytorch  RNN  tqdm  安装 基于迭代器  Pillow  图像大小限制[14]  常用函数 anaconda  卸载[15]  参考文献   "}),a.add({id:20,href:'/note/%E7%BC%96%E7%A8%8B/rust/',title:"Rust",section:"编程",content:"Cargo 新建项目 cargo new ${name}  默认使用 --bin 参数。\n 语法 命名惯例[1]  表 1: Rust 命名惯例  项目 惯例    Crates snake_case, prefer single word  Modules snake_case  Types CamelCase  Traits CamelCase  Functions snake_case  Methods snake_case  一般的构造函数 new 或者 with_more_details  转换构造函数 from_some_other_type  Local variables snake_case  Static variables SCREAMING_SNAKE_CASE  Constant variables SCREAMING_SNAKE_CASE  Type parameters 简洁的 CamelCase，比如 T  Lifetimes 简短的小写字母，比如 'a       首字母缩写词写成 Uuid，而不是 UUID   module[2]  如果模块 foo 没有子模块，则代码放在 foo.rs 如果模块 foo 有子模块，则代码放在 foo/mod.rs  类型  表 2: Rust 类型  语法 含义    \u0026amp;[T] slice     类型转换  表 3: Rust 类型转换  类型 转换方法    Option -\u0026gt; Result ok_or     String 多行 String[3] let string = \u0026quot;line one line two\u0026quot;; Iterator  表 4: Iterator 方法列表  方法 作用    filter_map 过滤并映射     Vec  表 5: Vec 常用方法  方法 含义    remove 移除某个元素     合并[4] let mut a = vec![1, 2, 3]; let b = vec![4, 5, 6];  a.extend(b); assert_eq!(a, [1, 2, 3, 4, 5, 6]); // b is moved and can\u0026#39;t be used anymore 静态 slice[5] static NUMBERS: \u0026amp;\u0026#39;static [i32] = \u0026amp;[1, 2, 3, 4, 5]; Enum[6] enum IpAddrKind {  V4,  V6, } fmt::Display[7] impl fmt::Display for Foo {  fn fmt(\u0026amp;self, f: \u0026amp;mut fmt::Formatter) -\u0026gt; fmt::Result {  write!(f, \u0026quot;{:?}\u0026quot;, self)  // or, alternatively:  // fmt::Debug::fmt(self, f)  } } macro  表 6: Rust 宏  macro 含义    #[allow(non_snake_case)] 关闭 snake_case 警告     diesel 安装 cargo install diesel_cli 用法  表 7: diesel 常用方法  方法 含义    load SELECT 后返回多条记录  into_boxed 用于改变 query  ge \u0026gt;=     参考文献 [1] RUST. Naming conventions[EB/OL]([日期不详]). https://doc.rust-lang.org/1.0.0/style/style/naming/README.html.\n [2] RUST. mod and the Filesystem[EB/OL]([日期不详]). https://doc.rust-lang.org/1.30.0/book/2018-edition/ch07-01-mod-and-the-filesystem.html.\n [3] HUON. What is the syntax for a multiline string literal?[EB/OL](2015–04–07). https://stackoverflow.com/a/29483453/13200985.\n [4] LUD. Best way to concatenate vectors in Rust[EB/OL](2016–11–24). https://stackoverflow.com/a/40795247/13200985.\n [5] MORGAN C. How to specify const array in global scope in Rust?[EB/OL](2014–05–22). https://stackoverflow.com/a/23810557/13200985.\n [6] RUST. Defining an Enum[EB/OL]([日期不详]). https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html.\n [7] MATVEEV V. How do I get an enum as a string?[EB/OL](2015–09–22). https://stackoverflow.com/a/32712140/13200985.\n  目录  Cargo  新建项目  语法  命名惯例[1] module[2] 类型 类型转换 String  多行 String[3]  Iterator Vec  合并[4]  静态 slice[5] Enum[6] fmt::Display[7] macro  diesel  安装 用法  参考文献   "}),a.add({id:21,href:'/note/%E7%BC%96%E7%A8%8B/TeX/',title:"TeX",section:"编程",content:"符号  表 1: 符号  数学表达式 含义 \\(\\TeX\\) 表示    \\(\\infty\\) 无穷 \\infty  \\(\\forall\\) 任意 \\forall     矩阵  表 2: 矩阵相关表示  数学表达式 含义 \\(\\TeX\\) 表示    \\(\\m{A}\\) 矩阵 \\m{A}  \\(\\T{A}\\) 转置 \\T{A}  \\(\\langle, \\rangle\\) 内积 \\langle, \\rangle  \\(\\otimes\\) 外积 \\otimes  \\(\\odot\\) Hadamard product \\odot[1]  \\(\\lVert a\\rVert\\) 模长 \\lVert a\\rVert     函数  表 3: 函数相关表示  数学表达式 含义 \\(\\TeX\\) 表示    \\(f: \\R^2\\to\\R\\) 函数的作用域 f: \\R^2\\to\\R  \\(\\int_0^1 p(r)\\d r\\) 积分 \\int_0^1 p(r)\\d r     集合  表 4: 集合相关表示  数学表达式 含义 \\(\\TeX\\) 表示    \\(\\{n \\mid 0 \\le n \\le 19\\}\\) 集合 \\{n \\mid 0 \\le n \\le 19\\}  \\(\\R\\) 实数集 \\R  \\(A\\cap B\\) A 与 B 的交集 A\\cap B  \\(\\vert A\\vert\\) A 的元素个数 \\vert A\\vert     统计  表 5: 统计相关表示  数学表达式 含义 \\(\\TeX\\) 表示    \\(\\mean{p}\\) 平均值 \\mean{p}     数论  表 6: 数论相关表示  数学表达式 含义 \\(\\TeX\\) 表示    \\(\\lfloor x\\rfloor\\) 向下取整 \\lfloor x\\rfloor     运算符  表 7: 运算符  运算符 含义 \\(\\TeX\\) 表示    \\(\\sum_{k=1}^n P(k)\\) 求和 \\sum_{k=1}^n P(k)     数学表达式  表 8: 数学表达式  数学表达式 含义 \\(\\TeX\\) 表示    \\(\\tilde{A}\\) 变体 \\tilde{A}  \\(\\hat{y}\\) 计算值 \\hat{y}     公式对齐[2] \\[ \\begin{align} 2x - 5y \u0026amp;= 8 \\\\ 3x + 9y \u0026amp;= -12 \\end{align} \\]\n\\begin{align} 2x - 5y \u0026amp;= 8 \\\\ 3x + 9y \u0026amp;= -12 \\end{align}  align* 表示不编号[3]。\n 条件分支 \\[ f(x) = \\begin{cases} \\frac{x^2-x}{x}, \u0026amp; \\mathrm{if }\\; x\\ge 1\\\\ 0, \u0026amp; \\mathrm{otherwise} \\end{cases} \\]\nf(x) = \\begin{cases} \\frac{x^2-x}{x}, \u0026amp; \\mathrm{if }\\;x\\ge1\\\\ 0, \u0026amp; \\mathrm{otherwise} \\end{cases} 参考文献 [1] HOLT K. Element-wise (or pointwise) operations notation?[EB/OL](2013–12–10). https://math.stackexchange.com/a/601545.\n [2] OVERLEAF. Aligning equations with amsmath[EB/OL]([日期不详]). https://www.overleaf.com/learn/latex/Aligning_equations_with_amsmath.\n [3] KOTTWITZ S. What’s the difference between align and align*?[EB/OL](2011–01–23). https://tex.stackexchange.com/a/9515.\n  目录  符号 矩阵 函数 集合 统计 数论 运算符 数学表达式 公式对齐[2] 条件分支 参考文献   "}),a.add({id:22,href:'/note/%E7%BC%96%E7%A8%8B/toml/',title:"Toml",section:"编程",content:"Table[1] [table] 参考文献 [1] TOML. TOML[EB/OL]([日期不详]). https://github.com/toml-lang/toml.\n  目录  Table[1] 参考文献   "}),a.add({id:23,href:'/note/NLP/Transformer/',title:"Transformer",section:"NLP",content:"输入输出[1]  图 1: 输入输出  Self-Attention 步骤[1] Embedding  图 2: Embedding  把符号变成向量。\n \\(d_e = 512\\)\n Query、Key 和 Value 向量  图 3: Q、K 和 V  通过乘 \\(\\m{W}^{\\m{Q}}, \\m{W}^{\\m{K}}, \\m{W}^{\\m{V}}\\)，每个单词都可以得到自己的 \\(\\v{q}, \\v{k}, \\v{v}\\) 向量。\n  \\(d_q = d_k = 64\\) \\(d_v = 64\\)   Self-Attention  图 4: Self-Attention  矩阵形式  图 5: 矩阵形式的 Self-Attention  Multi-Head  图 6: Multi-Head  多头可以区分不同的表示子空间。\n 图 7: Multi-Head 输出  总结  图 8: Self-Attention 总结  Positional Encoding[1]  图 9: Positional Encoding  Residual[1]  图 10: 残差与 LayerNorm  Decoder[1]  图 11: Decoder   Masked Multi-Head Attention 层只考虑上文，会屏蔽下文 Encoder-Decoder Attention 层的 Q 来自于下层，K、V 来自于 encoder  模型输出[1]  图 12: 模型输出  模型结构[2]  图 13: 模型结构  参考文献 [1] ALAMMAR J. The Illustrated Transformer[EB/OL](2018–06–27). http://jalammar.github.io/illustrated-transformer/.\n [2] VASWANI A, SHAZEER N, PARMAR N, 等. Attention is all you need[C]//Advances in neural information processing systems..\n  目录  输入输出[1] Self-Attention 步骤[1]  Embedding Query、Key 和 Value 向量 Self-Attention 矩阵形式 Multi-Head 总结  Positional Encoding[1] Residual[1] Decoder[1] 模型输出[1] 模型结构[2] 参考文献   "}),a.add({id:24,href:'/note/%E8%A7%86%E8%A7%89/unity/',title:"Unity",section:"视觉",content:"导入 .obj 文件时 x 轴会取反[1] 参考文献 [1] STACKOVERFLOW. Unity flips x coordinate in obj using importer at runtime[EB/OL](2018–08–27). https://stackoverflow.com/a/52044185.\n  目录  导入 .obj 文件时 x 轴会取反[1] 参考文献   "}),a.add({id:25,href:'/note/%E5%B7%A5%E5%85%B7/Windows/',title:"Windows",section:"工具",content:"常用软件  表 1: Windows 常用软件  软件名 功能    7-zip 压缩  Scoop 软件管理  Total Commander 文件管理     Scoop 设置代理 scoop config proxy 127.0.0.1:3128 Total Commander  配置 -\u0026gt; 深色模式 配置 -\u0026gt; 选项 -\u0026gt; 显示 -\u0026gt; 制表位 -\u0026gt; 文件大小显示 -\u0026gt; 动态(x KB/MB/GB) 配置 -\u0026gt; 选项 -\u0026gt; 操作方式 -\u0026gt; 鼠标选择方式 -\u0026gt; 通过左键选择  Adobe Acrobat Pro DC 2019 请参考 https://www.isharepc.com/10839.html。\nAdobe Photoshop 2021 请参考 https://www.isharepc.com/10255.html。\n不用 Fn 按出 F2 请参考 https://zhidao.baidu.com/question/1576316896877270700.html。\nPPT 插入圆角矩阵 请参考 https://zhidao.baidu.com/question/520937235.html。\n调整圆角矩形的圆角大小 调整小黄点位置，具体请参考 https://zhidao.baidu.com/question/309456592.html。\n取色器 请参考 https://support.office.com/zh-cn/article/%E4%BD%BF%E7%94%A8%E5%8F%96%E8%89%B2%E5%99%A8%E5%8C%B9%E9%85%8D%E5%B9%BB%E7%81%AF%E7%89%87%E4%B8%8A%E7%9A%84%E9%A2%9C%E8%89%B2-d5e7a32a-da6c-4bed-9f1e-8797f07174e9。\n参考文献 目录  常用软件  Scoop  设置代理  Total Commander Adobe Acrobat Pro DC 2019 Adobe Photoshop 2021  不用 Fn 按出 F2 PPT  插入圆角矩阵 调整圆角矩形的圆角大小 取色器  参考文献   "}),a.add({id:26,href:'/note/%E5%B7%A5%E5%85%B7/Word/',title:"Word",section:"工具",content:"参考文献相关操作 合并连续引用 请参考 https://hzfans.github.io/2018/06/10/2018-6-10%20Word%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8%E7%9A%84%E8%BF%9E%E7%BB%AD%E5%A4%9A%E9%A1%B9%E5%BC%95%E7%94%A8/。\n对齐列表 在任一编号上右键单击 -\u0026gt; 调整列表缩进：\n 文本缩进位置可以调大一点，比如 0.9 厘米 点击更多：  编号之后，选制表符 选中制表符添加位置，写与文本缩进位置相同的值，本例中为 0.9 厘米   插入引用 请参考 https://jingyan.baidu.com/article/cd4c2979113a05756f6e6047.html。\n更新文档中的所有域[1] Ctrl + A -\u0026gt; F9。\n显示或隐藏文档中所有表格的网格线 请参考 https://support.office.com/zh-cn/article/%E6%98%BE%E7%A4%BA%E6%88%96%E9%9A%90%E8%97%8F%E6%96%87%E6%A1%A3%E4%B8%AD%E6%89%80%E6%9C%89%E8%A1%A8%E6%A0%BC%E7%9A%84%E7%BD%91%E6%A0%BC%E7%BA%BF-84780485-af90-49b1-82a0-682cd7fc9dad。\n输入上下标 请参考 https://jingyan.baidu.com/article/f3ad7d0fc4ca3209c3345b84.html。\n特殊符号 波浪号 请参考 https://zhuanlan.zhihu.com/p/76387600。\n正负号 请参考 https://zhidao.baidu.com/question/538973023.html。\n分页符 请参考 https://www.office68.com/word/8512.html。\n横向纸张 请参考 https://support.office.com/zh-cn/article/%E5%B0%86%E9%A1%B5%E9%9D%A2%E6%96%B9%E5%90%91%E6%9B%B4%E6%94%B9%E4%B8%BA%E6%A8%AA%E5%90%91%E6%88%96%E7%BA%B5%E5%90%91-9b5ac1af-9998-4a37-962b-a82b689572a9。\n调整页边距 请参考 https://support.microsoft.com/zh-cn/office/%E5%9C%A8-word-%E4%B8%AD%E8%AE%BE%E7%BD%AE%E6%88%96%E6%9B%B4%E6%94%B9%E9%A1%B5%E8%BE%B9%E8%B7%9D-72fa6264-7df4-48f3-b805-2ffb6f32bd54。\n删除页眉横线 请参考 https://jingyan.baidu.com/article/f79b7cb3bb3c629144023e05.html。\n修改脚注上方的横线 请参考 https://zhidao.baidu.com/question/1895317289698826500.html。\n参考文献 [1] MICROSOFT. 更新文档中的所有域[EB/OL]([日期不详]). https://support.microsoft.com/zh-cn/office/%E6%9B%B4%E6%96%B0%E5%9F%9F-7339a049-cb0d-4d5a-8679-97c20c643d4e#_updateallfields.\n  目录  参考文献相关操作  合并连续引用 对齐列表 插入引用 更新文档中的所有域[1]  显示或隐藏文档中所有表格的网格线 输入上下标 特殊符号  波浪号 正负号  分页符 横向纸张 调整页边距 删除页眉横线 修改脚注上方的横线 参考文献   "}),a.add({id:27,href:'/note/%E7%BC%96%E7%A8%8B/zsh/',title:"Zsh",section:"编程",content:"插件管理 antibody 静态加载 antibody bundle \u0026lt; ~/.config/antibody/zsh_plugins.txt \u0026gt; ~/.config/antibody/zsh_plugins.sh 更新插件 antibody update 删除插件 antibody purge robbyrussell/oh-my-zsh 目录  插件管理  antibody  静态加载 更新插件 删除插件     "}),a.add({id:28,href:'/note/CS/transmission/',title:"传输",section:"CS",content:"SSH Secure Shell。\n只让某些用户使用密码登录 PasswordAuthentication no Match User \u0026lt;username\u0026gt; PasswordAuthentication yes  Match 在遇到下一个 Match 前一直有效，与缩进无关。\n SFTP SSH File Transfer Protocol。\n常见命令  表 1: SFTP 常见命令  功能 命令 选项    上传 put \u0026lt;local_dir\u0026gt;/*.mp4 \u0026lt;remote_dir\u0026gt;/ -r，递归  下载 put \u0026lt;remote_dir\u0026gt;/*.mp4 \u0026lt;local_dir\u0026gt;/ -r，递归  移动文件 rename      internal-sftp vs sftp-server 推荐使用 internal-sftp。[1]\nvsftpd Very Secure FTP Daemon。\n只允许某些用户访问[2] /etc/vsftpd.conf:\nuserlist_enable=YES userlist_file=/etc/vsftpd.userlist userlist_deny=NO INVALIDARGUMENT[3] /etc/vsftpd.conf:\nlisten=YES 530 Login incorrect[4] /etc/vsftpd.conf:\npam_service_name=ftp [1] PRIKRYL M. OpenSSH: Difference between internal-sftp and sftp-server[EB/OL](2015–01–17). https://serverfault.com/a/660325.\n [2] MARK. vsftpd: allow access only for certain users[EB/OL](2011–03–06). https://serverfault.com/a/243821.\n [3] JACK S. vsftpd-cannot read config file even when file exists[EB/OL](2016–09–15). https://askubuntu.com/a/825114.\n [4] AZKERM. vsftpd: 530 Login incorrect[EB/OL](2014–01–31). https://askubuntu.com/a/413694.\n  目录  SSH  只让某些用户使用密码登录  SFTP  常见命令 internal-sftp vs sftp-server  vsftpd  只允许某些用户访问[2] INVALIDARGUMENT[3] 530 Login incorrect[4]    "}),a.add({id:29,href:'/note/%E5%B7%A5%E5%85%B7/writing/',title:"写作",section:"工具",content:"Pandoc 安装 nix-env -iA nixpkgs.haskellPackages.pandoc-citeproc nix-env -iA nixpkgs.haskellPackages.pandoc-crossref 打印默认模板 pandoc --print-default-template=html 静态网站生成器 静态网站生成器列表：https://www.staticgen.com/。\nHugo 常用命令 # 查看程序版本 hugo version  # 创建网站 hugo new site quickstart  # 添加主题 git submodule add https://github.com/ribice/kiss.git themes/kiss  # 添加内容 hugo new posts/my-first-post.md 主题  文档：https://github.com/alex-shpak/hugo-book 博客：https://github.com/ribice/kiss  部署到 GitHub Pages 请参考 https://github.com/peaceiris/actions-gh-pages#getting-started。\nMathJax \u0026lt;script\u0026gt; MathJax = {  tex: {  inlineMath: [[\u0026#39;$\u0026#39;, \u0026#39;$\u0026#39;], [\u0026#39;\\\\(\u0026#39;, \u0026#39;\\\\)\u0026#39;]]  },  svg: {  fontCache: \u0026#39;global\u0026#39;  } }; \u0026lt;/script\u0026gt; \u0026lt;scripttype=\u0026quot;text/javascript\u0026quot;id=\u0026quot;MathJax-script\u0026quot;async src=\u0026quot;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js\u0026quot;\u0026gt; \u0026lt;/script\u0026gt;  MathJax 对象需要在加载 MathJax 脚本前初始化。\n Citation Style Language Official repository for Citation Style Language (CSL) citation styles: https://github.com/citation-style-language/styles。\n目录  Pandoc  安装 打印默认模板  静态网站生成器  Hugo  常用命令 主题  部署到 GitHub Pages MathJax  Citation Style Language   "}),a.add({id:30,href:'/note/LeetCode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/',title:"动态规划",section:"LeetCode",content:"一维 123 买卖股票的最佳时机 III 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成两笔交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(K)\\)  int max_profit(vector\u0026lt;int\u0026gt; \u0026amp;prices) {  int K = 2;  // dp[j][0]: 卖出 j 次的最大利润  // dp[j][1]: 买入 j 次的最大利润  int dp[K + 1][2];  for (int j = 0; j \u0026lt;= K; j++) {  dp[j][0] = 0;  dp[j][1] = INT_MIN;  }  for (auto price : prices) {  for (int j = 1; j \u0026lt;= K; j++) {  dp[j][0] = std::max(dp[j][0], dp[j][1] + price);  dp[j][1] = std::max(dp[j][1], dp[j - 1][0] - price);  }  }  return dp[K][0]; } 二维 44 通配符匹配 给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 ? 和 * 的通配符匹配。\n ? 可以匹配任何单个字符 * 可以匹配任意字符串（包括空字符串）  动态规划  时间复杂度：\\(O(mn)\\) 空间复杂度：\\(O(mn)\\)  bool is_match(string s, string p) {  int m = s.size();  int n = p.size();  // dp[i][j]: is_match(s[0:i], p[0:j])  vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; dp(m + 1, vector\u0026lt;bool\u0026gt;(n + 1, false));  dp[0][0] = true;  for (int j = 1; j \u0026lt;= n; j++) {  if (p[j - 1] == \u0026#39;*\u0026#39;) {  dp[0][j] = true;  } else {  break;  }  }  for (int i = 1; i \u0026lt;= m; i++) {  for (int j = 1; j \u0026lt;= n; j++) {  if (p[j - 1] == \u0026#39;*\u0026#39;) {  dp[i][j] = dp[i][j - 1] || dp[i - 1][j];  } else if (p[j - 1] == \u0026#39;?\u0026#39; || s[i - 1] == p[j - 1]) {  dp[i][j] = dp[i - 1][j - 1];  }  // fmt::print(\u0026quot;s: {}, p: {}, dp[{}][{}]: {}\\n\u0026quot;, s, p, i, j,  // dp[i][j]);  }  }  return dp[m][n]; } 贪心算法  时间复杂度  渐进复杂度：\\(O(mn)\\) 平均复杂度：\\(O(m\\log n)\\)  空间复杂度：\\(O(1)\\)  bool is_match_v2(string s, string p) {  auto is_char_match = [](const char \u0026amp;c_s, const char \u0026amp;c_p) {  return c_p == \u0026#39;?\u0026#39; || c_s == c_p;  };  while (!s.empty() \u0026amp;\u0026amp; !p.empty() \u0026amp;\u0026amp; p.back() != \u0026#39;*\u0026#39;) {  if (is_char_match(s.back(), p.back())) {  s.pop_back();  p.pop_back();  } else {  return false;  }  }  if (p.empty()) {  return s.empty();  }  int i_s = 0, i_p = 0;  int i_sub_start_s = -1, i_sub_start_p = -1;  while (i_s \u0026lt; s.size() \u0026amp;\u0026amp; i_p \u0026lt; p.size()) {  if (p[i_p] == \u0026#39;*\u0026#39;) {  i_p++;  i_sub_start_p = i_p;  i_sub_start_s = i_s;  } else if (is_char_match(s[i_s], p[i_p])) {  i_p++;  i_s++;  } else if (i_sub_start_s != -1) {  i_p = i_sub_start_p;  i_s = i_sub_start_s + 1;  i_sub_start_s = i_s;  } else {  return false;  }  }  while (i_p \u0026lt; p.size()) {  if (p[i_p] != \u0026#39;*\u0026#39;) {  return false;  }  i_p++;  }  return true; } 目录  一维  123 买卖股票的最佳时机 III  二维  44 通配符匹配  动态规划 贪心算法     "}),a.add({id:31,href:'/note/CS/compress/',title:"压缩",section:"CS",content:"tar 打包时排除某些目录[1] tar --exclude=\u0026#39;./folder1\u0026#39; --exclude=\u0026#39;./folder2\u0026#39; -czvf filename.tar.gz . 查看压缩包内容 tar -tvf filename.tar.gz 7z 安装 nix-env -iA nixpkgs.p7zip 参考文献 [1] STACKOVERFLOW. Shell command to tar directory excluding certain files/folders[EB/OL](2009–06–11). https://stackoverflow.com/a/984259.\n  目录  tar  打包时排除某些目录[1] 查看压缩包内容  7z  安装  参考文献   "}),a.add({id:32,href:'/note/%E8%A7%86%E8%A7%89/image/',title:"图像",section:"视觉",content:"文件格式  表 1: 图像文件格式  图像格式 无损？    PNG ✅  JPG ❌     ImageMagick 裁剪中间部分 convert a.png -gravity center -crop 16384x16384+0+0 b.png 压缩 JPG jpegoptim 安装  表 2: jpegoptim 安装命令  操作系统 命令    Arch Linux sudo pacman -S jpegoptim     colmap 安装[1] git clone https://github.com/colmap/colmap.git cd colmap git checkout dev mkdir build cd build CC=/usr/bin/gcc CXX=/usr/bin/g++ cmake .. CC=/usr/bin/gcc CXX=/usr/bin/g++ make sudo make install [1] COLMAP. Installation[EB/OL]([日期不详]). https://colmap.github.io/install.html#linux.\n  目录  文件格式 ImageMagick  裁剪中间部分  压缩  JPG  jpegoptim   colmap  安装[1]    "}),a.add({id:33,href:'/note/CS/security/',title:"安全",section:"CS",content:"SSH FAQ pam_access(sshd:account): access denied for user 请修改 /etc/security/access.conf 配置。\nGPG FAQ gpg: WARNING: server ‘gpg-agent’ is older than us gpgconf --kill -v gpg-agent 目录  SSH  FAQ  pam_access(sshd:account): access denied for user   GPG  FAQ  gpg: WARNING: server ‘gpg-agent’ is older than us     "}),a.add({id:34,href:'/note/AI/dev_env/',title:"开发环境",section:"AI",content:"CUDA  表 1: CUDA 与驱动的版本对应关系[1]  CUDA 版本 驱动版本    CUDA 11.1 \u0026gt;= 455.23.04  CUDA 11.0 \u0026gt;= 450.36.06  CUDA 10.2 \u0026gt;= 440.33  CUDA 10.1 \u0026gt;= 418.39     安装驱动 Ubuntu sudo add-apt-repository ppa:graphics-drivers/ppa ubuntu-drivers devices # 查看推荐的驱动 sudo apt install nvidia-430 # 安装驱动 Docker Docker \u0026gt;= 19.03 docker run --gpus=all --shm-size=64G kaizhang91/cuda:10.2 nvidia-smi Docker \u0026lt; 19.03 nvidia-docker run --shm-size=64G kaizhang91/cuda:10.2 nvidia-smi Jupyter Lab 安装 pip install jupyterlab 使用 jupyter lab Jupyter jupyter_contrib_nbextensions 安装 pip install jupyter_contrib_nbextensions jupyter contrib nbextension install --user 使用 打开 http://\u0026lt;host\u0026gt;:\u0026lt;port\u0026gt;/nbextensions 管理。\nPyTorch 安装 pip install torch torchvision 计算精度 correct = 0 total = 0 with torch.no_grad():  for data in testloader:  images, labels = data  outputs = net(images)  _, predicted = torch.max(outputs.data, 1)  total += labels.size(0)  correct += (predicted == labels).sum().item()  print(\u0026#39;Accuracy of the network on the 10000 test images: %d%%\u0026#39; % (  100 * correct / total)) 模型  evaluate 模型时，代码需要包含在 with torch.no_grad(): 里，避免计算梯度  Tensor  Tensor 可以用 GPU 加速计算 带 _ 后缀的方法改变张量 Tensor 在 CPU 上时，与 NumPy array 共享内存   表 2: torch.Tensor 常用方法  Tensor 方法 含义    size() 得到维数  view() resize（某个 size 为 -1 时用其他维数推断）  item() 得到里面的数字  numpy() 返回 NumPy array  from_numpy() 由 NumPy array 得到张量  detach() 不再参与计算     device device = torch.device(\u0026quot;cuda\u0026quot;) Module net.zero_grad() 可以清空存在的梯度，不然梯度会累积。\n参考文献 [1] NVIDIA. CUDA Compatibility[EB/OL]([日期不详]). https://docs.nvidia.com/deploy/cuda-compatibility/index.html.\n  目录  CUDA  安装驱动  Ubuntu   Docker  Docker \u0026gt;= 19.03 Docker \u0026lt; 19.03  Jupyter Lab  安装 使用  Jupyter  jupyter_contrib_nbextensions  安装 使用   PyTorch  安装 计算精度 模型 Tensor device Module  参考文献   "}),a.add({id:35,href:'/note/CS/ci/',title:"持续集成",section:"CS",content:"Ansible 安装  表 1: 安装 ansible  操作系统 命令    nix nix-env -iA nixpkgs.ansible     目录结构[1] inventories/  production/  hosts # inventory file for production servers  group_vars/  group1.yml # here we assign variables to particular groups  group2.yml  host_vars/  hostname1.yml # here we assign variables to particular systems  hostname2.yml   staging/  hosts # inventory file for staging environment  group_vars/  group1.yml # here we assign variables to particular groups  group2.yml  host_vars/  stagehost1.yml # here we assign variables to particular systems  stagehost2.yml  library/ module_utils/ filter_plugins/  site.yml webservers.yml dbservers.yml  roles/  common/  webtier/  monitoring/  fooapp/ 依赖 meta/main.yml:\ndependencies: -role:wheel vars: n:1 -role:wheel vars: n:2 -role:wheel vars: n:3 -role:wheel vars: n:4 嵌套循环 # main.yml -include_tasks:inner.yml loop: -1 -2 -3 loop_control: loop_var:outer_item  # inner.yml -debug: msg:\u0026quot;outer item={{ outer_item }} inner item={{ item }}\u0026quot; loop: -a -b -c 自定义 ssh 端口 [webservers] web01.somedomain.com ansible_port=1234 Ansible Vault systemd 文件目录 请放在 /etc/systemd/system/ 下面。[2]\n查看 mount 的转义路径 systemd-escape -p --suffix=mount \u0026quot;/tmp//waldi/foobar/\u0026quot; GitHub Actions 加密信息 请参考 https://help.github.com/en/actions/configuring-and-managing-workflows/creating-and-storing-encrypted-secrets。\n参考文献 [1] ANSIBLE. Alternative Directory Layout[EB/OL]([日期不详]). https://docs.ansible.com/ansible/latest/user_guide/playbooks_best_practices.html#alternative-directory-layout.\n [2] KOMAR J. Where do I put my systemd unit file?[EB/OL](2017–05–25). https://unix.stackexchange.com/a/367237.\n  目录  Ansible  安装 目录结构[1] 依赖 嵌套循环 自定义 ssh 端口 Ansible Vault  systemd  文件目录 查看 mount 的转义路径  GitHub  Actions  加密信息   参考文献   "}),a.add({id:36,href:'/note/AI/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/',title:"推荐系统",section:"AI",content:"术语  表 1: 术语  缩写 全称 含义    C Context 场景  CTR Click Through Rate 点击率  CVR Conversion Rate 转化率  DMP Data Management Platform 数据管理平台  FFM Field-aware Factorization Machine 域感知因子分解机  FM Factorization Machine 因子分解机  I Item 物品  MLP Multilayer Perception 多层感知机  U User 用户     架构  图 1: 推荐系统架构  算法 不同算法的优缺点  表 2: 不同算法的优缺点  算法 优点 缺点    UserCF 符合直觉（兴趣相似的朋友喜欢的物品，我也喜欢） 用户数远大于物品数   社交特性更强，适于发现热点 用户历史数据向量很稀疏  ItemCF 适于兴趣变化较为稳定的应用 泛化能力弱，头部效应强   直观，可解释性强 无法有效引入场景信息  矩阵分解 泛化能力强 不方便融合特征   空间复杂度低 不好冷启动   便于与神经网络集成   逻辑回归 融合多种特征 无法特征交叉、筛选   假设 \\(y\\) 服从伯努利分布，有物理意义    是各特征的加权和，可解释性强    易于并行化、模型简单、易于训练   POLY2 特征交叉 特征向量更稀疏，不好训练    参数增多  FM 参数从 POLY2 的 \\(n^2\\) 下降到 \\(nk\\)    比 POLY2 更适于稀疏数据，泛化能力强    易于上线   FFM 比 FM 表达能力强 计算复杂度上升到 \\(kn^2\\)  GBDT+LR 特征工程模型化   LS-PLM 能挖掘非线性模式    引入 L1 惩罚，模型稀疏   AutoRec 第一次使用深度学习框架   Deep Crossing 特征间深度交叉   NeuralCF 用户向量和物品向量更充分地交叉 没有引入更多特征   表达能力比矩阵分解强    可以灵活选择互操作层   PNN 强调不同特征之间的交互 简化操作丢失信息  Wide \u0026amp; Deep 综合记忆能力和泛化能力    开拓了融合不同网络结构的新思路   Deep \u0026amp; Cross Wide 部分的特征自动交叉   DIEN 预测下一次购买，更符合业务目标 训练复杂度高    串行推断  DRN 变静态为动态，在线训练      协同过滤 共现矩阵 用户为行坐标（记用户总数为 \\(m\\)）、物品为列坐标（即物品总数为 \\(n\\)）的 \\(m\\times n\\) 维矩阵。\n相似度 余弦相似度 \\[\\sim(\\v{i},\\v{j}) = \\cos(\\v{i}, \\v{j}) = \\frac{\\v{i}\\cdot\\v{j}}{\\lVert\\v{i}\\rVert\\cdot\\lVert\\v{j}\\rVert}\\qquad(1)\\]\n其中，\\(\\v{i}\\)、\\(\\v{j}\\) 均表示用户向量。\n皮尔逊相关系数 \\[\\sim(i,j) = \\frac{\\sum_{p\\in P}(R_{i,p} - \\mean{R_i})(R_{j,p}-\\mean{R_j})}{\\sqrt{\\sum_{p\\in P}(R_{i,p}-\\mean{R_i})^2}\\sqrt{\\sum_{p\\in P}(R_{j,p}-\\mean{R_j})^2}}\\qquad(2)\\]\n其中，\\(R_{i,p}\\) 表示用户 \\(i\\) 对物品 \\(p\\) 的评分；\\(\\mean{R_i}\\) 表示用户 \\(i\\) 对所有物品的平均评分；\\(P\\) 代表所有物品的集合。\n 皮尔逊相关系数减小了用户评分偏置的影响。\n 皮尔逊相关系数拓展 \\[\\sim(i,j) = \\frac{\\sum_{p\\in P}(R_{i,p} - \\mean{R_p})(R_{j,p}-\\mean{R_p})}{\\sqrt{\\sum_{p\\in P}(R_{i,p}-\\mean{R_p})^2}\\sqrt{\\sum_{p\\in P}(R_{j,p}-\\mean{R_p})^2}}\\qquad(3)\\]\n其中，\\(R_{i,p}\\) 表示用户 \\(i\\) 对物品 \\(p\\) 的评分；\\(\\mean{R_p}\\) 表示物品 \\(p\\) 的平均评分；\\(P\\) 代表所有物品的集合。\n 式. 3 减小了物品评分偏置的影响。\n UserCF 基于用户的协同过滤。\n\\[R_{u,p} = \\frac{\\sum_{s\\in S}w_{u,s}R_{s,p}}{\\sum_{s\\in S}w_{u,s}}\\qquad(4)\\]\n其中，\\(R_{s,p}\\) 表示用户 \\(s\\) 对物品 \\(p\\) 的评分；\\(w_{u,s}\\) 表示用户 \\(u\\) 与用户 \\(s\\) 的相似度。\n 根据用户向量找到 top n 相似用户 将相似用户对物品的评分加权平均，即可得到目标用户对物品的评分  ItemCF 基于物品相似度的协同过滤。\n\\[R_{u,p} = \\sum_{h\\in H}w_{p,h}R_{u,h}\\qquad(5)\\]\n其中，\\(R_{u,h}\\) 表示用户 \\(u\\) 对物品 \\(h\\) 的评分；\\(w_{p,h}\\) 表示物品 \\(p\\) 与物品 \\(h\\) 的相似度；\\(H\\) 表示用户 \\(u\\) 的正反馈物品集合。\n 根据物品向量找到 top k 相似物品 将用户对相似物品的评分加权平均，即得用户对目标物品的评分  矩阵分解 分解共现矩阵得到用户和物品的隐向量：\n\\[\\m{R} = \\m{U}\\m{V}\\qquad(6)\\]\n其中，\\(\\m{R}\\) 为 \\(m\\times n\\) 维的共现矩阵，\\(\\m{U}\\) 为 \\(m\\times k\\) 维的用户矩阵， \\(\\m{V}\\) 为 \\(k\\times n\\) 维的物品矩阵。\n\\[\\hat{r}_{ui} = \\T{\\v{q}}_i\\v{p}_u\\qquad(7)\\]\n其中，\\(\\v{p}_u\\) 表示 \\(\\m{U}\\) 的第 \\(u\\) 行组成的向量，\\(\\v{q}_i\\) 表示 \\(\\m{V}\\) 中的第 \\(i\\) 列组成的向量。\n奇异值分解  共现矩阵有大量缺失值，不适于直接 SVD 计算复杂度高  梯度下降 损失函数：\n\\[\\min\\sum_{(u,i)\\in K}(r_{ui} - \\T{\\v{q}}_i\\v{p}_u)^2\\qquad(8)\\]\n其中，\\(K\\) 是所有用户评分样本的集合。\n消除用户和物品打分的偏差 \\[\\hat{r}_{ui} = \\mu + b_i + b_u + \\T{\\v{q}}_i\\v{p}_u\\qquad(9)\\]\n其中，\\(\\mu\\) 是全局偏差，\\(b_i\\) 是物品偏差，\\(b_u\\) 是用户偏差。\n逻辑回归 输出 \\[\\hat{y} = \\sigmoid(\\T{\\v{x}}\\v{w} + b)\\qquad(10)\\]\n损失函数 \\[ \\begin{align} J(\\v{w}) \u0026amp;= \\frac{1}{m}\\sum_{i=1}^m H(p(\\v{y}), p(\\hat{\\v{y}})) \\\\ \u0026amp;= -\\frac{1}{m}\\sum_{i=1}^m[y_i\\log f_{\\v{w}}(\\v{x}_i) + (1-y_i)\\log (1-f_{\\v{w}}(\\v{x}_i))] \\end{align} \\qquad(11)\\]\n 也可以用极大似然估计解释，\\(P(y\\mid \\v{x};\\v{w}) = (f_{\\v{w}}(\\v{x}))^y(1-f_{\\v{w}}(\\v{x}))^{1-y}\\)。\n FM -\u0026gt; FFM POLY2 \\[\\phi\\mathrm{POLY2}(\\v{w},\\v{x}) = \\sum_{j_1=1}^{n-1}\\sum_{j_2=j_1+1}^n w_{h(j_1,j_2)}x_{j_1}x_{j_2}\\qquad(12)\\]\nFM \\[\\phi\\mathrm{FM}(\\v{w},\\v{x}) = \\sum_{j_1=1}^{n-1}\\sum_{j_2=j_1+1}^n (\\v{w}_{j_1}\\cdot\\v{w}_{j_2})x_{j_1}x_{j_2}\\qquad(13)\\]\nFFM \\[\\phi\\mathrm{FFM}(\\v{w},\\v{x}) = \\sum_{j_1=1}^{n-1}\\sum_{j_2=j_1+1}^n (\\v{w}_{j_1,f_2}\\cdot\\v{w}_{j_2,f_1})x_{j_1}x_{j_2}\\qquad(14)\\]\nGBDT + LR  图 2: GBDT+LR 架构  LS-PLM 输出 \\[ \\begin{align} f(\\v{x}) \u0026amp;= \\sum_{i=1}^m \\pi_i(\\v{x})\\cdot\\eta_i(\\v{x}) \\\\ \u0026amp;= \\sum_{i=1}^m \\frac{\\e^{\\v{\\mu_i}\\cdot\\v{x}}}{\\sum_{j=1}^m\\e^{\\v{\\mu_j}\\cdot\\v{x}}}\\cdot\\frac{1}{1+\\e^{-\\v{w_i}\\cdot\\v{x}}} \\end{align} \\qquad(15)\\]\n其中，\\(m\\) 为分片数，\\(\\pi\\) 为聚类函数（这里采用 softmax 对样本进行多分类）。\nAutoRec  图 3: AutoRec 架构[1]  损失函数 \\[\\min_{\\theta}\\left[\\sum_{\\v{r}\\in S}\\lVert\\v{r}-h(\\v{r};\\theta)\\rVert_2^2 + \\frac{\\lambda}{2}(\\lVert\\m{W}_F^2\\rVert + \\lVert\\m{V}\\rVert_F^2)\\right]\\qquad(16)\\]\n其中，\\(h(\\v{r};\\theta)\\) 为重建函数；\\(\\v{r}^{(i)}=\\T{(R_{1i},\\dots,R_{mi})}\\) 为物品 \\(i\\) 的评分向量。\n重建函数 \\[h(\\v{r};\\theta)=f(\\m{W}\\cdot g(\\m{V}\\v{r}+\\mu)+b)\\qquad(17)\\]\n输出 \\[\\hat{R}_{ui} = h(\\v{r}^{(i)};\\theta)_u\\qquad(18)\\]\nDeep Crossing  图 4: Deep Crossing 架构[2]  残差神经网络 好处：\n 减少过拟合 减弱梯度消失现象，加快收敛速度  NeuralCF 用多层神经网络代替矩阵分解的内积操作。\n 图 5: NeuralCF 架构[3]  PNN 乘积层代替 Deep Crossing 模型中的 Stacking 层。\n 图 6: PNN 架构[4]  Wide \u0026amp; Deep  图 7: Wide \u0026amp; Deep 架构[5]  Cross Product Transformation 为：\n\\[\\phi_k(\\v{x}) = \\prod_{i=1}^d x_i^{c_{ki}}\\quad c_{ki}\\in\\{0,1\\}\\]\n其中，\\(c_{ki}\\) 当第 \\(i\\) 个特征属于第 \\(k\\) 个组合特征时为 \\(1\\)，否则为 \\(0\\)；\\(x_i\\) 是第 \\(i\\) 个特征的值。\nDeep \u0026amp; Cross  图 8: Deep \u0026amp; Cross 架构[6]  Cross 网络的运算为：\n\\[\\v{x}_{l+1} = \\v{x}_0\\T{\\v{x}_l}\\v{w}_l + \\v{b}_l + \\v{x}_l\\qquad(19)\\]\nFNN 用 FM 的隐向量初始化 Embedding 层。\n为什么 Embedding 层收敛速度较慢？\n Embedding 参数多 输入向量稀疏   图 9: FNN 架构[7]  其中，\\(\\v{w}\\) 和 \\(\\v{v}\\) 对应于 FM 中的参数：\n\\[\\hat{\\v{y}} = \\sigmoid\\left(w_0 + \\sum_{i=1}^N w_i x_i + \\sum_{i=1}^N\\sum_{j=i+1}^N\\langle\\v{v}_i,\\v{v}_j\\rangle x_i x_j\\right) \\qquad(20)\\]\nDeepFM  图 10: DeepFM 架构[8]  NFM 用神经网络代替 FM 的二阶特征交叉。\n 图 11: NFM 架构[9]  Bi-Interaction Pooling 具体操作为：\n\\[f_{\\mathrm{BI}}(\\mathcal{V}_x) = \\sum_{i=1}^n\\sum_{j=i+1}^n x_i\\v{v}_i\\odot x_j\\v{v}_j\\qquad(21)\\]\n其中，\\(\\mathcal{V}_x\\) 是 Embedding 集合。\nAFM  图 12: AFM 架构[10]  特征交叉采用元素积：\n\\[f_{\\mathrm{PI}}(\\mathcal{E}) = \\{(\\v{v}_i\\odot\\v{v}_j) x_i x_j\\mid (i,j)\\in\\mathcal{R}_x\\}\\qquad(22)\\]\n其中，PI 表示 Pair-wise Interaction Layer；\\(\\mathcal{E} = \\{\\v{v}_i x_i\\mid i\\in\\mathcal{X}\\}\\)；\\(\\mathcal{X}\\) 为非零特征的索引集合；\\(\\mathcal{R}_x = \\{(i,j)\\mid i\\in\\mathcal{X}, j\\in\\mathcal{X}, j\u0026gt;i\\}\\)。\n\\[ \\begin{align} f_{\\mathrm{Att}}(f_{\\mathrm{PI}}(\\mathcal{E})) \u0026amp;= \\sum_{(i,j)\\in\\mathcal{R}_x} a_{ij}(\\v{v}_i\\odot\\v{v}_j) x_i x_j \\\\ a_{ij} \u0026amp;= \\frac{\\exp(a\u0026#39;_{ij})}{\\sum_{(i,j)\\in\\mathcal{R}_x}\\exp(a\u0026#39;_{ij})} \\\\ a\u0026#39;_{ij} \u0026amp;= \\T{\\v{h}}\\ReLU(\\m{W}(\\v{v}_i\\odot\\v{v}_j)x_i x_j +\\v{b}) \\end{align} \\qquad(23)\\]\nDIN  图 13: DIN 架构[11]  注意力 \\[\\v{v}_U(A) = f(\\v{v}_A,\\v{e}_1,\\v{e}_2,\\dots,\\v{e}_H) = \\sum_{j=1}^H a(\\v{e}_j,\\v{v}_A)\\v{e}_j = \\sum_{j=1}^H w_j\\v{e}_j\\qquad(24)\\]\n其中，\\(\\{\\v{e}_1,\\v{e}_2,\\dots,\\v{e}_H\\}\\) 是用户 U 的历史行为的 Embedding 向量； \\(\\v{v}_A\\) 是广告 A 的 Embedding 向量。\nDIEN  图 14: DIEN 架构[12]  AUGRU AUGRU 改变了更新门：\n\\[\\tilde{\\v{u}}\u0026#39;_t = a_t\\v{u}\u0026#39;_t\\qquad(25)\\]\nDRN  图 15: 深度强化学习推荐系统[13]   State representation 为用户特征，Action representation 为候选新闻特征 用户向 Agent 请求新闻列表，Agent 根据 State representation 和 Action representation 选择最好的 Action 返回给用户，并获取用户反馈 Action 和反馈日志会存入 Agent 的内存，Agent 每小时会利用内存中的日志更新推荐算法   图 16: DRN Q 网络[13]   图 17: DRN 模型框架[13]  竞争梯度下降法  图 18: 竞争梯度下降法[13]  \\[\\Delta\\m{W} = \\alpha\\cdot\\rand(-1,1)\\cdot\\m{W}\\qquad(26)\\]\n其中，\\(\\alpha\\) 是探索因子。\nEmbedding 不同 Embedding 的优缺点  表 3: 不同 Embedding 的优缺点  Embedding 优点 缺点    Word2vec 奠基   Item2vec 没有时间窗口 只有序列型结构  EGES 缓解冷启动      Word2vec  图 19: CBOW 与 Skip-gram 架构[14]   根据经验，Skip-gram 的效果更好  基本结构  图 20: word2vec 基本网络结构[15]  输出 \\[y_j = p(w_j\\mid w_I) = \\frac{\\exp(\\T{\\v{v}\u0026#39;_{w_j}}\\v{v}_{w_I})}{\\sum_{j\u0026#39;=1}^V\\exp(\\T{\\v{v}\u0026#39;_{w_{j\u0026#39;}}}\\v{v}_{w_I})} \\qquad(27)\\]\n其中，\\(\\v{v}_{w_I}\\in\\R^{N\\times 1}\\) 为 \\(\\m{W}\\) 的第 \\(I\\) 行； \\(\\v{v}\u0026#39;_{w_j}\\in\\R^{N\\times 1}\\) 为 \\(\\m{W}\u0026#39;\\) 的第 \\(j\\) 列。\\(\\m{W}\\) 为词向量矩阵。\n损失函数 \\[L = -\\log p(w_O\\mid w_I)\\qquad(28)\\]\n其中，\\(O\\) 为输出单词的索引；这个损失可以看做最大似然概率，也可以看做交叉熵。\n负采样 \\[L = -\\log \\sigma(\\T{\\v{v}\u0026#39;_{w_O}}\\v{h}) - \\sum_{w_j\\in\\mathcal{W}_{\\mathrm{neg}}}\\log\\sigma(-\\T{\\v{v}\u0026#39;_{w_j}}\\v{h}) \\qquad(29)\\]\n其中，\\(w_O\\) 是输出单词；\\(\\mathcal{W}_{\\mathrm{neg}} = \\{w_j\\mid j=1,\\cdots,K\\}\\) 是采样得到的负样本集合。\nItem2vec DeepWalk  图 21: DeepWalk 架构[16]  随机游走的转移概率[16] \\[ P(v_j\\mid v_i) = \\begin{cases} \\frac{M_{ij}}{\\sum_{j\u0026#39;\\in N_+(v_i)}M_{ij\u0026#39;}}, \u0026amp;\\mathrm{if}\\;v_j\\in N_+(v_i)\\\\ 0, \u0026amp;\\mathrm{if}\\;e_{ij}\\notin\\mathcal{E} \\end{cases} \\]\n其中，\\(N_+(v_i)\\) 表示 \\(v_i\\) 的出边集合；\\(M_{ij}\\) 表示节点 \\(i\\) 到节点 \\(j\\) 边的权重；\\(\\mathcal{E}\\) 表示所有边的集合。\nnode2vec  图 22: node2vec 广度优先搜索与深度优先搜索[17]   同质性：图. 22 中的 \\(u\\) 与 \\(s_1\\) 属于同一社区，Embedding 应该相似 同构性：图. 22 中的 \\(u\\) 与 \\(s_6\\) 扮演相似的结构角色， Embedding 应该相似 BFS 能发现同构性；DFS 能发现同质性  跳转概率  图 23: node2vec 跳转概率[17]  未归一化的跳转概率为：\n\\[\\pi_{vx} = \\alpha_{pq}(t,x)\\cdot w_{vx}\\qquad(30)\\]\n其中，\n\\[ \\alpha_{pq}(t,x) = \\begin{cases} \\frac{1}{p}\\quad \u0026amp;\\mathrm{if}\\;d_{tx} = 0\\\\ 1 \u0026amp;\\mathrm{if}\\;d_{tx} = 1\\\\ \\frac{1}{q}\\quad \u0026amp;\\mathrm{if}\\;d_{tx} = 2 \\end{cases} \\qquad(31)\\]\n\\(t\\) 为上一个节点；\\(w_{vx}\\) 是边 \\(vx\\) 的权重；\\(d_{tx}\\) 表示节点 \\(t\\) 与节点 \\(x\\) 的最短距离；\\(p\\) 为返回参数；\\(q\\) 为进出参数。\nEGES  图 24: EGES 架构[16]  隐层向量 \\[\\m{H}_v = \\frac{\\sum_{j=0}^n \\e^{a_v^j}\\m{W}_v^j}{\\sum_{j=0}^n \\e^{a_v^j}}\\]\n使用 \\(e^{a_v^j}\\) 作为权重是想让权重总是大于 \\(0\\)。\n局部敏感哈希 欧式空间中，将高维空间的点映射到低维空间：\n 原本相近的点在低维空间肯定依然相近 原本远离的点则有一定概率变成相近的点  \\[h^{\\v{x},b} = \\left\\lfloor\\frac{\\v{v}\\cdot\\v{x} + b}{w}\\right\\rfloor\\qquad(32)\\]\n特征工程 原则  尽可能暴露有用信息 尽量摈弃冗余信息  召回策略  表 4: 召回层与排序层  层 目标 特点    召回层 尽量让用户感兴趣的物品被快速召回 候选集合大、速度快、模型简单、特征较少  排序层 得到精准的排序结果 候选集合小、模型复杂、特征较多     冷启动的解决办法 基于规则的冷启动 丰富冷启动过程中可获得的用户和物品特征  用户的注册信息 第三方 DMP 提供的用户信息 物品的内容特征 引导用户输入的冷启动特征  利用主动学习、迁移学习和“探索与利用”机制 “探索与利用”机制 UCB (Upper Confidence Bound，置信区间上界)：\n\\[\\mathrm{UCB}(j) = \\mean{x_j}+\\sqrt{\\frac{2\\ln n}{n_j}}\\qquad(33)\\]\n其中，\\(\\mean{x_j}\\) 为第 \\(j\\) 个物品的平均回报；\\(n_j\\) 为第 \\(j\\) 个物品的曝光次数； \\(n\\) 为所有物品的曝光次数。可以看到，UCB 倾向于推荐冷启动的物品。\n推荐模型离线训练 Spark MLib Parameter Server  分布式梯度下降策略：同步阻断 -\u0026gt; 异步非阻断 多 server 使用一致性哈希、参数范围拉取、参数范围推送，减小带宽  推荐系统的评估 Holdout 检验 K-fold 交叉验证 把 K 次评估指标的平均值作为最终的评估指标。\n参考文献 [1] SEDHAIN S, MENON A K, SANNER S, 等. Autorec: Autoencoders meet collaborative filtering[C]//Proceedings of the 24th international conference on World Wide Web..\n [2] SHAN Y, HOENS T R, JIAO J, 等. Deep crossing: Web-scale modeling without manually crafted combinatorial features[C]//Proceedings of the 22nd ACM SIGKDD international conference on knowledge discovery and data mining..\n [3] HE X, LIAO L, ZHANG H, 等. Neural collaborative filtering[C]//Proceedings of the 26th international conference on world wide web..\n [4] QU Y, CAI H, REN K, 等. Product-based neural networks for user response prediction[C]//2016 IEEE 16th International Conference on Data Mining (ICDM). IEEE, 2016: 1149–1154.\n [5] CHENG H-T, KOC L, HARMSEN J, 等. Wide \u0026amp; deep learning for recommender systems[C]//Proceedings of the 1st workshop on deep learning for recommender systems..\n [6] WANG R, FU B, FU G, 等. Deep \u0026amp; cross network for ad click predictions[M]//Proceedings of the ADKDD’17..\n [7] ZHANG W, DU T, WANG J. Deep learning over multi-field categorical data[C]//European conference on information retrieval. Springer, 2016: 45–57.\n [8] GUO H, TANG R, YE Y, 等. DeepFM: a factorization-machine based neural network for CTR prediction[J]. arXiv preprint arXiv:1703.04247, 2017.\n [9] HE X, CHUA T-S. Neural factorization machines for sparse predictive analytics[C]//Proceedings of the 40th International ACM SIGIR conference on Research and Development in Information Retrieval..\n [10] XIAO J, YE H, HE X, 等. Attentional factorization machines: Learning the weight of feature interactions via attention networks[J]. arXiv preprint arXiv:1708.04617, 2017.\n [11] ZHOU G, ZHU X, SONG C, 等. Deep interest network for click-through rate prediction[C]//Proceedings of the 24th ACM SIGKDD International Conference on Knowledge Discovery \u0026amp; Data Mining..\n [12] ZHOU G, MOU N, FAN Y, 等. Deep interest evolution network for click-through rate prediction[C]//Proceedings of the AAAI conference on artificial intelligence..\n [13] ZHENG G, ZHANG F, ZHENG Z, 等. DRN: A deep reinforcement learning framework for news recommendation[C]//Proceedings of the 2018 World Wide Web Conference..\n [14] MIKOLOV T, CHEN K, CORRADO G, 等. Efficient estimation of word representations in vector space[J]. arXiv preprint arXiv:1301.3781, 2013.\n [15] RONG X. word2vec parameter learning explained[J]. arXiv preprint arXiv:1411.2738, 2014.\n [16] WANG J, HUANG P, ZHAO H, 等. Billion-scale commodity embedding for e-commerce recommendation in alibaba[C]//Proceedings of the 24th ACM SIGKDD International Conference on Knowledge Discovery \u0026amp; Data Mining..\n [17] GROVER A, LESKOVEC J. node2vec: Scalable feature learning for networks[C]//Proceedings of the 22nd ACM SIGKDD international conference on Knowledge discovery and data mining..\n  目录  术语 架构 算法  不同算法的优缺点 协同过滤  共现矩阵 相似度 UserCF ItemCF  矩阵分解  奇异值分解 梯度下降 消除用户和物品打分的偏差  逻辑回归  输出 损失函数  FM -\u0026gt; FFM  POLY2 FM FFM  GBDT + LR LS-PLM  输出  AutoRec  损失函数 重建函数 输出  Deep Crossing  残差神经网络  NeuralCF PNN Wide \u0026amp; Deep Deep \u0026amp; Cross FNN DeepFM NFM AFM DIN  注意力  DIEN  AUGRU  DRN  竞争梯度下降法   Embedding  不同 Embedding 的优缺点 Word2vec  基本结构  Item2vec DeepWalk  随机游走的转移概率[16]  node2vec  跳转概率  EGES  隐层向量  局部敏感哈希  特征工程  原则  召回策略 冷启动的解决办法  基于规则的冷启动 丰富冷启动过程中可获得的用户和物品特征 利用主动学习、迁移学习和“探索与利用”机制  “探索与利用”机制   推荐模型离线训练  Spark MLib Parameter Server  推荐系统的评估  Holdout 检验 K-fold 交叉验证  参考文献   "}),a.add({id:37,href:'/note/%E5%B7%A5%E5%85%B7/search/',title:"搜索",section:"工具",content:'搜索命令 navi 安装 NAVI_VERSION=2.4.1 curl -LO \u0026quot;https://github.com/denisidoro/navi/releases/download/v$NAVI_VERSION/navi-v$NAVI_VERSION-x86_64-unknown-linux-musl.tar.gz\u0026quot; tar -xzvf navi-v$NAVI_VERSION-x86_64-unknown-linux-musl.tar.gz mv -i navi ~/.local/bin/ 使用 Ctrl-g。\n搜索目录 zoxide 安装 curl --proto \u0026#39;=https\u0026#39; --tlsv1.2 -sSf https://raw.githubusercontent.com/ajeetdsouza/zoxide/master/install.sh | sh 使用 zi 查找字符串 ripgrep 在 python 文件里搜索 rg -tpy foo 非正则匹配 rg -F \u0026#39;C-^\u0026#39; 在 pandoc 文件里搜索短线 rg -g \u0026#39;*.pandoc\u0026#39; -- ---- grep[1] grep -rl \u0026quot;string\u0026quot; /path 参考文献 [1] ASKUBUNTU. How to use "grep" command to find text including subdirectories[EB/OL](2011–08–01). https://askubuntu.com/questions/55325/how-to-use-grep-command-to-find-text-including-subdirectories.\n  目录  搜索命令  navi  安装 使用   搜索目录  zoxide  安装 使用   查找字符串  ripgrep  在 python 文件里搜索 非正则匹配 在 pandoc 文件里搜索短线  grep[1]  参考文献   '}),a.add({id:38,href:'/note/LeetCode/%E6%95%B0%E5%AD%97/',title:"数字",section:"LeetCode",content:"50 Pow(x, n) 实现 pow(x, n)，即计算 x 的 n 次幂函数。\n快速幂 + 递归  时间复杂度：\\(O(\\log n)\\) 空间复杂度：\\(O(\\log n)\\)  double quick_pow(double x, long long N) {  if (N == 0) {  return 1.0;  } else {  double y = quick_pow(x, N / 2);  return N % 2 == 0 ? y * y : y * y * x;  } }  double my_pow(double x, int n) {  long long N = n;  return n \u0026gt;= 0 ? quick_pow(x, N) : 1.0 / quick_pow(x, -N); } 快速幂 + 迭代  时间复杂度：\\(O(\\log n)\\) 空间复杂度：\\(O(1)\\)  double quick_pow_v2(double x, long long N) {  double result = 1.0;  double x_contribute = x;  while (N \u0026gt; 0) {  if (N % 2 == 1) {  result *= x_contribute;  }  x_contribute *= x_contribute;  N /= 2;  }  return result; }  double my_pow_v2(double x, int n) {  long long N = n;  return n \u0026gt;= 0 ? quick_pow_v2(x, N) : 1.0 / quick_pow_v2(x, -N); } 69 x 的平方根 实现 int sqrt(int x) 函数。计算并返回 x 的平方根，其中 x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。\n二分查找  时间复杂度：\\(O(\\log x)\\) 空间复杂度：\\(O(1)\\)  int my_sqrt(int x) {  int l = 0;  int h = x;  int result = -1;  while (l \u0026lt;= h) {  int mid = l + (h - l) / 2;  if ((long long)mid * mid \u0026lt;= x) {  result = mid;  l = mid + 1;  } else {  h = mid - 1;  }  }  return result; } 牛顿迭代法  时间复杂度：\\(O(\\log x)\\) 空间复杂度：\\(O(1)\\)  int my_sqrt_v2(int x) {  if (x == 0) {  return 0;  }  double C = x;  double x0 = C;  while (true) {  double x1 = x0 / 2 + C / (2 * x0);  if (fabs(x0 - x1) \u0026lt; 1e-7) {  break;  }  x0 = x1;  }  return (int)x0; } 数学函数法  时间复杂度：\\(O(1)\\) 空间复杂度：\\(O(1)\\)  int my_sqrt_v3(int x) {  if (x == 0) {  return 0;  }  int result = exp(0.5 * log(x));  return (long long)(result + 1) * (result + 1) \u0026lt;= x ? result + 1 : result; } 1018 可被 5 整除的二进制前缀 给定由若干 0 和 1 组成的数组 A。我们定义 N_i：从 A[0] 到 A[i] 的第 i 个子数组被解释为一个二进制数（从最高有效位到最低有效位）。返回布尔值列表 answer，只有当 N_i 可以被 5 整除时，答案 answer[i] 为 true，否则为 false。\n 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(1)\\)  vector\u0026lt;bool\u0026gt; prefix_div_by_5(vector\u0026lt;int\u0026gt; \u0026amp;A) {  int n = A.size();  vector\u0026lt;bool\u0026gt; result(n);  int pre = 0;  for (int i = 0; i \u0026lt; n; i++) {  pre = ((pre \u0026lt;\u0026lt; 1) + A[i]) % 5;  result[i] = (pre == 0);  }  return result; } 目录  50 Pow(x, n)  快速幂 + 递归 快速幂 + 迭代  69 x 的平方根  二分查找 牛顿迭代法 数学函数法  1018 可被 5 整除的二进制前缀   "}),a.add({id:39,href:'/note/CS/database/',title:"数据库",section:"CS",content:"Entity Relationship Diagram 安装 curl -LO \u0026#39;https://github.com/BurntSushi/erd/releases/download/v0.2.1.0-RC1/erd_static-x86-64\u0026#39; chmod u+x erd_static-x86-64 cp -i erd_static-x86-64 ~/.local/bin/erd SQL 命名规范  表 1: SQL 命名规范  类别 规范 例子    表名 单数[1] user  identifiers snake case[2] lower_case_with_underscores  user 使用非保留关键词 user_     PostgreSQL 安装 Arch Linux $ sudo pacman -S postgres $ sudo -iu postgres [postgres]$ initdb -D /var/lib/postgres/data [postgres]$ exit $ sudo systemctl start postgresql.service $ sudo systemctl enable postgresql.service Ubuntu UBUNTU_VERSION=xenial echo \u0026quot;deb http://apt.postgresql.org/pub/repos/apt/ $UBUNTU_VERSION-pgdg main\u0026quot; | sudo tee /etc/apt/sources.list.d/pgdg.list wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add - sudo apt update sudo apt install postgresql 创建用户 $ sudo -iu postgres [postgres]$ createuser --interactive # --pwprompt 要求输入密码 创建数据库 createdb \u0026lt;name\u0026gt; 注释 -- 注释 数据类型[3]  表 2: PostgreSQL 数据类型  数据类型 含义    bool 布尔值  varchar(n) 变长字符串  real float     psql 指令  表 3: psql 指令  指令 含义    \\du 列出用户  \\l list all databases  \\dt 列出表  \\d \u0026lt;table_name\u0026gt; 显示表定义     参数替换[4] PREPARE fooplan (int, text, bool, numeric) AS  INSERT INTO foo VALUES($1, $2, $3, $4); EXECUTE fooplan(1, \u0026#39;Hunter Valley\u0026#39;, \u0026#39;t\u0026#39;, 200.00); 模糊查找[5] LIKE 时间和空间复杂度上限更容易控制。\n按拼音排序[6] SELECT * FROM a ORDER BY c1 COLLATE \u0026quot;zh_CN\u0026quot;; 参考文献 [1] GBN. Plural vs Singular Table Name[EB/OL](2012–02–23). https://dba.stackexchange.com/a/13737.\n [2] LEONBLOY. PostgreSQL naming conventions[EB/OL](2010–05–20). https://stackoverflow.com/a/2878408/13200985.\n [3] POSTGRESQL. Chapter 8. Data Types[EB/OL]([日期不详]). https://www.postgresql.org/docs/current/datatype.html.\n [4] POSTGRESQL. PREPARE[EB/OL]([日期不详]). https://www.postgresql.org/docs/current/sql-prepare.html.\n [5] POSTGRESQL. Pattern Matching[EB/OL]([日期不详]). https://www.postgresql.org/docs/current/functions-matching.html.\n [6] 阿里云. 设置数据库的本土化信息及字符串排序规则[EB/OL]([日期不详]). https://www.alibabacloud.com/help/zh/doc-detail/52950.htm#h2-u8BBEu7F6Eu8F93u51FAu7ED3u679Cu6309u62FCu97F3u6392u5E8F3.\n  目录  Entity Relationship Diagram  安装  SQL 命名规范 PostgreSQL  安装  Arch Linux Ubuntu  创建用户 创建数据库 注释 数据类型[3] psql 指令 参数替换[4] 模糊查找[5] 按拼音排序[6]  参考文献   "}),a.add({id:40,href:'/note/CS/data-type/',title:"数据类型",section:"CS",content:"科学计数法[1] mEn 表示 \\(m \\times 10^n\\)。\n数据类型  表 1: 数据类型  数据类型 bit 数 精度    double 64 \\(2^{-52}\\)，即 \\(2.22\\times 10^{-16}\\)     时间格式  表 2: 时间格式  标准 例子 命令    rfc-3339 2020-05-05 22:59:40+08:00 date --rfc-3339=seconds  iso-8601 2020-05-05T22:58:30+08:00 date -Iseconds     参考文献 [1] WIKIPEDIA. Scientific notation[EB/OL]([日期不详]). https://en.wikipedia.org/wiki/Scientific_notation.\n  目录  科学计数法[1] 数据类型 时间格式 参考文献   "}),a.add({id:41,href:'/note/LeetCode/%E6%95%B0%E7%BB%84/',title:"数组",section:"LeetCode",content:"一维数组 未排序的数组 169 众数 给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n哈希表  时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(n)\\)  int major_element_v1(vector\u0026lt;int\u0026gt; \u0026amp;nums) {  std::unordered_map\u0026lt;int, int\u0026gt; m;  int n = nums.size();  for (auto num : nums) {  if (++m[num] \u0026gt; (n / 2)) {  return num;  }  }  return -1; } Boyer-Moore 投票法  时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(1)\\)  int major_element(vector\u0026lt;int\u0026gt; \u0026amp;nums) {  int result = nums[0];  int count = 1;  for (int i = 1; i \u0026lt; nums.size(); ++i) {  if (nums[i] == result) {  count++;  } else {  if (count \u0026gt; 0) {  count--;  } else {  result = nums[i];  count = 1;  }  }  }  return result; } 189 旋转数组 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。\n使用额外数组  时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(n)\\)  void rotate_v1(vector\u0026lt;int\u0026gt; \u0026amp;nums, int k) {  int n = nums.size();  vector\u0026lt;int\u0026gt; tmp(n);  for (int i = 0; i \u0026lt; n; i++) {  tmp[(i + k) % n] = nums[i];  }  nums.assign(tmp.begin(), tmp.end()); } 翻转  时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(1)\\)  void reverse(vector\u0026lt;int\u0026gt; \u0026amp;nums, int i0, int i1) {  while (i0 \u0026lt; i1) {  std::swap(nums[i0], nums[i1 - 1]);  i0++;  i1--;  } }  void rotate_v2(vector\u0026lt;int\u0026gt; \u0026amp;nums, int k) {  int n = nums.size();  k = k % n;  reverse(nums, 0, n);  reverse(nums, 0, k);  reverse(nums, k, n); } 环状替换  时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(1)\\)  void rotate(vector\u0026lt;int\u0026gt; \u0026amp;nums, int k) {  int n = nums.size();  int count = std::__gcd(n, k);  for (int start = 0; start \u0026lt; count; start++) {  int i = start;  int pre = nums[i];  do {  int i_next = (i + k) % n;  std::swap(nums[i_next], pre);  i = i_next;  } while (i != start);  } } 41 缺失的第一个正数 给你一个未排序的整数数组 nums，请你找出其中没有出现的最小的正整数。\n哈希表  时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(1)\\)  int first_missing_positive(vector\u0026lt;int\u0026gt; \u0026amp;nums) {  int n = nums.size();  for (auto \u0026amp;num : nums) {  if (num \u0026lt;= 0) {  num = n + 1;  }  }  for (int i = 0; i \u0026lt; n; i++) {  int index = abs(nums[i]) - 1;  if (index \u0026lt; n \u0026amp;\u0026amp; nums[index] \u0026gt; 0) {  nums[index] *= -1;  }  }  for (int i = 0; i \u0026lt; n; i++) {  if (nums[i] \u0026gt; 0) {  return i + 1;  }  }  return n + 1; } 置换  时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(1)\\)  int first_missing_positive_v2(vector\u0026lt;int\u0026gt; \u0026amp;nums) {  int n = nums.size();  for (int i = 0; i \u0026lt; n; i++) {  while (nums[i] \u0026gt; 0 \u0026amp;\u0026amp; nums[i] \u0026lt;= n \u0026amp;\u0026amp; nums[nums[i] - 1] != nums[i]) {  std::swap(nums[i], nums[nums[i] - 1]);  }  }  for (int i = 0; i \u0026lt; n; i++) {  if (nums[i] != i + 1) {  return i + 1;  }  }  return n + 1; } 排序的数组 88 合并两个有序数组 给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。\n从末尾开始遍历。\n 时间复杂度：\\(O(m+n)\\) 空间复杂度：\\(O(1)\\)  void merge(vector\u0026lt;int\u0026gt; \u0026amp;nums1, int m, vector\u0026lt;int\u0026gt; \u0026amp;nums2, int n) {  int i1 = m - 1, i2 = n - 1, i = m + n - 1;  while (i1 \u0026gt;= 0 \u0026amp;\u0026amp; i2 \u0026gt;= 0) {  nums1[i--] = nums1[i1] \u0026lt; nums2[i2] ? nums2[i2--] : nums1[i1--];  }  while (i2 \u0026gt;= 0) {  nums1[i--] = nums2[i2--];  } } 二维数组 数独 36 数独是否有效 判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。\n 1-9 在每一行只能出现一次。\n 1-9 在每一列只能出现一次。\n 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。\n 时间复杂度：$O(1)\n 空间复杂度：$O(1)\n  bool is_valid_sudoku(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;board) {  int n = board.size();  std::unordered_map\u0026lt;char, int\u0026gt; row;  vector\u0026lt;std::unordered_map\u0026lt;char, int\u0026gt;\u0026gt; column(n);  vector\u0026lt;std::unordered_map\u0026lt;char, int\u0026gt;\u0026gt; box(n);  for (int i = 0; i \u0026lt; n; i++) {  row.clear();  for (int j = 0; j \u0026lt; n; j++) {  if (board[i][j] != \u0026#39;.\u0026#39;) {  row[board[i][j]]++;  if (row[board[i][j]] \u0026gt; 1) {  return false;  }  column[j][board[i][j]]++;  if (column[j][board[i][j]] \u0026gt; 1) {  return false;  }  box[(i / 3) * 3 + j / 3][board[i][j]]++;  if (box[(i / 3) * 3 + j / 3][board[i][j]] \u0026gt; 1) {  return false;  }  }  }  }  return true; } 图 连通性 547 省份数量 有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。省份是一组直接或间接相连的城市，组内不含其他没有相连的城市。给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。返回矩阵中省份的数量。\nDFS  时间复杂度：\\(O(n^2)\\) 空间复杂度：\\(O(n)\\)  void dfs(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;isConnected, vector\u0026lt;bool\u0026gt; \u0026amp;visited, int i) {  for (int j = 0; j \u0026lt; isConnected.size(); j++) {  if (!visited[j] \u0026amp;\u0026amp; isConnected[i][j] == 1) {  visited[j] = true;  dfs(isConnected, visited, j);  }  } }  int find_circle_num(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;isConnected) {  int n = isConnected.size();  if (n == 0) {  return 0;  }   vector\u0026lt;bool\u0026gt; visited(n, false);  int result = 0;  for (int i = 0; i \u0026lt; n; i++) {  if (!visited[i]) {  result++;  dfs(isConnected, visited, i);  }  }  return result; } BFS  时间复杂度：\\(O(n^2)\\) 空间复杂度：\\(O(n)\\)  int find_circle_num_v2(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;isConnected) {  int n = isConnected.size();  if (n == 0) {  return 0;  }   vector\u0026lt;bool\u0026gt; visited(n, false);  std::queue\u0026lt;int\u0026gt; q;  int result = 0;  for (int i = 0; i \u0026lt; n; i++) {  if (!visited[i]) {  result++;  q.push(i);  while (!q.empty()) {  auto front = q.front();  q.pop();  visited[front] = true;  for (int j = 0; j \u0026lt; n; j++) {  if (!visited[j] \u0026amp;\u0026amp; isConnected[front][j] == 1) {  q.push(j);  }  }  }  }  }  return result; } 并查集  时间复杂度：\\(O(n^2\\log n)\\) 空间复杂度：\\(O(n)\\)  int find_root(vector\u0026lt;int\u0026gt; \u0026amp;root, int i) {  if (root[i] != i) {  root[i] = find_root(root, root[i]);  }  return root[i]; }  void union_tree(vector\u0026lt;int\u0026gt; \u0026amp;root, int i, int j) {  root[find_root(root, i)] = find_root(root, j); }  int find_circle_num_v3(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;isConnected) {  int n = isConnected.size();  vector\u0026lt;int\u0026gt; root(n);  for (int i = 0; i \u0026lt; n; i++) {  root[i] = i;  }  for (int i = 0; i \u0026lt; n; i++) {  for (int j = i + 1; j \u0026lt; n; j++) {  if (isConnected[i][j] == 1) {  union_tree(root, i, j);  }  }  }  int result = 0;  for (int i = 0; i \u0026lt; n; i++) {  if (root[i] == i) {  result++;  }  }  return result; } 684 冗余连接 在本问题中, 树指的是一个连通且无环的无向图。输入一个图，该图由一个有着N个节点(节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u \u0026lt; v，表示连接顶点 u 和 v 的无向图的边。返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u \u0026lt; v。\n并查集。\n 时间复杂度  最坏情况：\\(O(N\\log N)\\) 平均情况：\\(O(N\\alpha (N))\\)  空间复杂度：\\(O(N)\\)  int find_root(vector\u0026lt;int\u0026gt; \u0026amp;root, int node) {  if (root[node] != node) {  root[node] = find_root(root, root[node]);  }  return root[node]; }  void union_tree(vector\u0026lt;int\u0026gt; \u0026amp;root, int i, int j) {  root[find_root(root, j)] = find_root(root, i); }  vector\u0026lt;int\u0026gt; find_redundant_connection(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;edges) {  int n = edges.size();  vector\u0026lt;int\u0026gt; root(n);  for (int i = 0; i \u0026lt; n; i++) {  root[i] = i;  }  vector\u0026lt;int\u0026gt; result;  for (auto edge : edges) {  if (find_root(root, edge[0] - 1) != find_root(root, edge[1] - 1)) {  union_tree(root, edge[0] - 1, edge[1] - 1);  } else {  result = edge;  }  }  return result; } 目录  一维数组  未排序的数组  169 众数 189 旋转数组 41 缺失的第一个正数  排序的数组  88 合并两个有序数组   二维数组  数独  36 数独是否有效   图  连通性  547 省份数量 684 冗余连接     "}),a.add({id:42,href:'/note/%E5%B7%A5%E5%85%B7/%E6%96%87%E7%8C%AE%E7%AE%A1%E7%90%86/',title:"文献管理",section:"工具",content:"Zotero 安装 Zotero  从 https://www.zotero.org/download/ 下载 Zotero，安装到本地 打开编辑 -\u0026gt; 首选项 -\u0026gt; 同步：  登录 zotero 账户，用于同步元信息 取消勾选同步全文内容（Zotero 只有 300M 免费空间，容量不够） 取消勾选同步文献库中的附件 取消勾选使用 Zotero 云存储同步群组文献库中的附件   Zotero Connector 访问 https://www.zotero.org/download/，把 Zotero Connector 安装到浏览器。\nZotfile  插件在坚果云里的小宝贝/zotfile-5.1.0.kai-fx.xpi 打开工具 -\u0026gt; 插件 -\u0026gt; 齿轮图标 -\u0026gt; Install Add-on From File...，安装到 Zotero 重启 Zotero 打开编辑 -\u0026gt; 首选项 -\u0026gt; 高级 -\u0026gt; 文件和文件夹，把根目录改为坚果云的某个目录，将来 pdf 等文件会存到这里 打开工具 -\u0026gt; Zotfile Preferences...：  打开 General Settings：  把 Source Folder For Attaching New Files 改为浏览器的下载目录，将来使用 Attach New File 的时候会从这个目录移动最新的文件 把 Location of Files 改为 Custom Location: 坚果云的某个目录，注意需要与上面的根目录保持一致 选中 Use subfolder defined by，后面填入 /%c，表示会按条目左侧的分类创建文件夹存储文件  打开 Renaming Rules：  Format for all Item Type except Patents 写 {%a_}{%y_}{%t} Format for Patents 写 {%a_}{%y_}{%t}  打开 Advanced Settings：  Only work with the following filetypes 写 pdf,doc,docx,txt,rtf,djvu,caj,epub    zotero-fullcreator  访问 https://github.com/normanfoster/zotero-fullcreator，下载 xpi 文件 打开工具 -\u0026gt; 插件 -\u0026gt; 齿轮图标 -\u0026gt; Install Add-on From File...，安装到 Zotero 重启 Zotero 在条目表格里：  取消勾选创建者 勾选 Author(s) 可以把 Author(s) 移动到第 2 列   使用  在 Google Scholar 或者中国知网上用 Zotero Connector 添加新条目 用 Sci-Hub 或者中国知网下载文献 在新条目上右键单击，选 Attach New File，注意观察下是不是刚刚下载的文献  目录  Zotero  安装  Zotero Zotero Connector Zotfile zotero-fullcreator  使用    "}),a.add({id:43,href:'/note/AI/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/',title:"机器学习",section:"AI",content:"采样[1]  表 1: 是否放回的区别  放回？ 英文 含义    不放回 without replacement 每个样本最多被采样一次  放回 with replacement 一个样本可能被采样多次     中位数 评估指标  表 2: 混淆矩阵   实际 Positive 实际 Negative    预测 Positive True Positive False Positive（误报，Type I Error）  预测 Negative False Negative（漏报，Type II Error） True Negative     精确率（Precision） 你认为的正样本，有多少猜对了（猜的精确性如何）[2]：\n\\[ P = \\frac{\\TP}{\\TP + \\FP}\\qquad(1)\\]\n在信息检索领域这样定义[3]：\n\\[ P = \\frac{\\vert\\{\\textrm{relevant documents}\\}\\cap\\{\\textrm{retrieved documents}\\}\\vert}{\\vert\\{\\textrm{retrieved documents}\\}\\vert}\\qquad(2)\\]\nP@n 只考虑 top n 个查询结果。[3]\n召回率（Recall） 正样本有多少被找出来了（召回了多少）[2]：\n\\[R = \\frac{\\TP}{\\TP + \\FN}\\qquad(3)\\]\n准确率（Accuracy） 预测正确的结果占总样本的比例[4]：\n\\[A = \\frac{\\TP+\\TN}{\\TP+\\TN+\\FP+\\FN}\\qquad(4)\\]\n\\(F_1\\) Precision 与 Recall 的调和均值：\n\\[\\frac{2}{F_1} = \\frac{1}{P} + \\frac{1}{R}\\qquad(5)\\]\n 调和均值受极小值的影响更大\n 真阳性率（TPR）[5] 在所有实际为阳性的样本中，被正确地判断为阳性之比率：\n\\[ \\TPR = \\frac{\\TP}{\\TP + \\FN}\\qquad(6)\\]\n与召回率定义相同。\n伪阳性率（FPR）[5] 在所有实际为阴性的样本中，被错误地判断为阳性之比率：\n\\[ \\FPR = \\frac{\\FP}{\\FP + \\TN}\\qquad(7)\\]\nROC 与 Precision-Recall 曲线[6]  图 1: 一个 ROC 与 Precision-Recall 曲线例子   图 2: ROC 与 Precision-Recall 曲线随阈值的动态变化  ROC 与 P-R 曲线的比较[6]  图 3: 样本不平衡时，ROC 与 Precision-Recall 曲线的比较   当正负样本不平衡时，P-R 曲线对误报更敏感  AUC(Area Under the Curve) ROC AUC  图 4: ROC AUC 示意图  ROC AUC 表示随机正类别（绿色）样本位于随机负类别（红色）样本右侧的概率。[7]\nPR AUC PR AUC 表示在不同召回率阈值下的平均精确率。[8]\nAveP(Average Precision)[3] AveP 为 PR AUC，具体地：\n\\[\\AveP = \\int_0^1 p(r)\\d r\\qquad(8)\\] \\[\\AveP = \\sum_{k=1}^n P(k)\\Delta r(k)\\qquad(9)\\] \\[\\AveP = \\frac{\\sum_{k=1}^n P(k)\\times \\rel(k)}{\\vert\\{\\textrm{relevant documents}\\}\\vert}\\qquad(10)\\]\n其中，\n \\(k\\) 表示在检索文档序列里的排名 \\(n\\) 表示检索文档的总数，\\(P(k)\\) 表示 top k 的精确率 \\(\\Delta r(k)\\) 表示从项 \\(k-1\\) 到 \\(k\\) 的召回率变化 \\(\\rel(k)\\) 是指示函数，项 \\(k\\) 是相关文档时为 \\(1\\)，项 \\(k\\) 不是相关文档时为 \\(0\\)  MAP(Mean Average Precision) \\[\\MAP = \\frac{\\sum_{q=1}^Q \\AveP(q)}{Q}\\qquad(11)\\]\n其中 \\(Q\\) 表示查询总数。\n信息论 条件熵[9] \\[ \\begin{align} H(Y\\mid X) \u0026amp;= \\sum_{x\\in\\mathcal{X}}p(x)H(Y\\mid X=x) \\\\ \u0026amp;= -\\sum_{x\\in\\mathcal{X},y\\in\\mathcal{Y}}p(x,y)\\log\\frac{p(x,y)}{p(x)} \\end{align} \\qquad(12)\\]\n输出层 sigmoid \\[f(z) = \\frac{1}{1+e^{-z}}\\qquad(13)\\]\n损失函数 交叉熵[10] \\[H(p, q) = -E_p[\\log q]\\qquad(14)\\]\n在离散情况下为\n\\[H(p, q) = -\\sum_{x\\in\\mathcal{X}}p(x)\\log q(x)\\qquad(15)\\]\n传统机器学习算法 决策树  分类树：\\(y\\) 离散 回归树：\\(y\\) 连续  ID3[11] 父节点的熵：\n\\[H(D) = -\\sum_{k=1}^K\\frac{|C_k|}{|D|}\\log\\frac{|C_k|}{|D|}\\]\n知道某个属性 A 后的条件熵：\n\\[H(D\\mid A) = \\sum_{i=1}^n\\frac{|D_i|}{|D|}H(D_i)\\]\n信息增益：\n\\[\\mathrm{Gain}(D, A) = H(D) - H(D\\mid A)\\]\n缺点：\n 信息增益偏向 \\(|A|\\) 大的属性  C4.5 信息增益比：\n\\[\\mathrm{Gain_{\\mathrm{ratio}}}(D, A) = \\frac{\\mathrm{Gain}(D,A)}{H_A(D)}\\]\n其中，\\(H_A(D) = -\\sum_{i=1}^n\\frac{|D_i|}{|D|}\\log\\frac{|D_i|}{|D|}\\)。\n缺点：\n 多叉树 只能分类  CART 分类 基尼系数：\n\\[\\mathrm{Gini}(D) = \\sum_{k=1}^K\\frac{|C_k|}{|D|}\\left(1-\\frac{|C_k|}{|D|}\\right)\\] \\[\\mathrm{Gini}(D, A) = \\frac{|D_1|}{|D|}\\mathrm{Gini}(D_1) + \\frac{|D_2|}{|D|}\\mathrm{Gini}(D_2)\\]\n用 \\(\\mathrm{Gini}(D, A)\\) 最小的属性 A 及切分点 a 分割 D。\n回归 按照\n\\[\\min_{a, s}\\left[\\min_{c_1}\\sum_{x_i\\in D_1}(y_i - c_1)^2 + \\min_{c_2}\\sum_{x_i\\in D_2}(y_i - c_2)^2\\right]\\]\n选择属性 \\(a\\) 与切分点 \\(s\\)。\n随机森林 对 \\(b=1,\\dots,B\\)：\n 从 \\(X,Y\\) 进行 \\(n\\) 次有放回的抽样，记为 \\(X_b,Y_b\\) 对 \\(X_b,Y_b\\) 训练决策树 \\(f_b\\)；每次分裂时只从特征的随机子集里选择 \\(\\hat{f} = \\frac{1}{B}\\sum_{b=1}^B f_b(x)\\)  优点：\n 泛化能力强 能处理高维数据，可以降维 可以处理缺失数据 可以并行  缺点：\n 黑盒 噪声较大时容易过拟合  GBDT 全称为 Gradient Boosting Decision Tree。\n优点：\n 预测阶段的计算速度快，树与树之间可并行计算 在分布稠密的数据集上，泛化能力和表达能力都很好，实战表现好 具有较好的解释性和鲁棒性，能够自动发现特征间的高阶关系，且不需要归一化等预处理  缺点：\n 在高维稀疏的数据集上，表现不如支持向量机或者神经网络 在处理分类特征时的优势不如处理数值特征时明显 需要迭代训练，即串行计算  损失函数 Square loss:\n\\[L(y, F) = \\frac{1}{2}(y-F(x))^2\\]\nAbsolute loss:\n\\[L(y, F) = |y-F(x)|\\]\nHuber loss:\n\\[ L(y, F) = \\begin{cases} \\frac{1}{2}(y-F(x))^2, \u0026amp; |y-F(x)| \\le\\delta\\\\ \\delta(|y-F(x)| - \\frac{\\delta}{2}), \u0026amp; |y-F(x)| \u0026gt; \\delta \\end{cases} \\]\n 表 3: 不同损失函数的比较  损失函数 优点 缺点    Square loss 数学性质好 对噪声敏感  Absolute loss 对噪声鲁棒   Huber loss 对噪声更鲁棒      回归的学习步骤 初始化 \\(F(x) = \\frac{\\sum_{i=1}^n y_i}{n}\\) 计算负梯度：\\(-g(x_i) = -\\frac{\\partial L(y_i,F(x_i))}{\\partial F(x_i)}\\) 按 \\(-g(x_i)\\) 拟合回归树 \\(h\\) 更新 F，\\(F := F + \\rho h\\) 终止或者跳到步骤 2  特征重要性  split：使用该特征的次数 gain：该特征的总增益  局部特征的贡献  图 5: GBDT 局部特征的贡献  XGBoost 树的输出 \\[f^{(t)}(\\v{x}) = w_{q(\\v{x})}, \\v{w}\\in \\R^T, q: \\R^d\\to \\{1,2,\\cdots,T\\}\\]\n其中，\\(T\\) 为叶子节点的数量；\\(d\\) 为 \\(\\v{x}\\) 的维度；\\(q\\) 把 \\(\\v{x}\\) 映射到某个叶子序号。\n\\[w_j = -\\frac{G_j}{H_j + \\lambda}\\] \\[G_j = \\sum_{i\\in I_j}g_i\\] \\[H_j = \\sum_{i\\in I_j}h_i\\] \\[I_j = \\{i\\mid q(\\v{x}_i) = j\\}\\] \\[g_i = \\frac{\\partial l(y_i, \\hat{y}_i^{(t-1)})}{\\partial\\hat{y}_i^{(t-1)}}\\] \\[h_i = \\frac{\\partial^2 l(y_i, \\hat{y}_i^{(t-1)})}{{\\partial\\hat{y}_i^{(t-1)}}^2}\\]\n树的损失函数 \\[J(f^{(t)}) = -\\frac{1}{2}\\sum_{j=1}^T\\frac{G_j^2}{H_j+\\lambda} + \\gamma T\\]\n节点分裂的增益 \\[\\mathrm{Gain} = \\frac{1}{2}\\left[\\frac{G_L^2}{H_L+\\lambda}+\\frac{G_R^2}{H_R+\\lambda}-\\frac{(G_L+G_R)^2}{H_L+H_R+\\lambda}\\right] - \\gamma\\]\n优点：\n 比 GBDT 性能更好 并行优化  与 GBDT 的区别：\n 除了支持 CART 树，还支持线性分类器 加了二阶导数 加了正则项，防止过拟合 支持列抽样 可以自动学习缺失值的分裂方向 预先排序，并行计算不同特征的增益  LightGBM 与 XGBoost 的区别：\n XGBoost 是 pre-sorted 算法，寻找数据分割点更精确；LightGBM 是 histogram 算法，占用内存小，计算复杂度低 XGBoost 是 level-wise 分裂，LightGBM 是 leaf-wise XGBoost 使用 pre-sorted 算法，通信代价大；LightGBM 使用 histogram 算法，通信代价小，能并行计算  K means 背景 给定样本 \\(\\{\\v{x}_1, \\v{x}_2, \\dots, \\v{x}_n\\}\\)，K means 希望把样本分成 \\(k\\) 类 \\(\\set{S} = \\{\\set{S}_1, \\set{S}_2, \\dots, \\set{S}_k\\}\\)，并且满足式. 16：\n\\[ \\argmin_{\\set{S}}\\sum_{i=1}^k\\sum_{\\v{x}\\in\\set{S}_i}\\lVert\\v{x}-\\v{\\mu}_i\\rVert^2 \\qquad(16)\\]\n迭代步骤 给定 k 个质心的初始值，然后重复以下步骤\n 赋值：把每个样本赋成距离最近的质心所在的类 更新：重新计算每个类的质心  初始化方法  Forgy：随机选择 k 个样本作为质心 Random Partition：每个样本随机赋一个类，计算每个类的质心  参考文献 [1] WIKIPEDIA. Sampling (statistics)[EB/OL]([日期不详]). https://en.wikipedia.org/wiki/Sampling_(statistics).\n [2] 张俊博. 如何解释召回率与精确率？[EB/OL](2018–05–08). https://www.zhihu.com/question/19645541/answer/360749257.\n [3] WIKIPEDIA. Evaluation measures (information retrieval)[EB/OL]([日期不详]). https://en.wikipedia.org/wiki/Evaluation_measures_(information_retrieval).\n [4] EASYAI. 一文看懂机器学习指标：准确率、精准率、召回率、F1、ROC曲线、AUC曲线[EB/OL](2019–11–21). https://medium.com/@pkqiang49/%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%8C%87%E6%A0%87-%E5%87%86%E7%A1%AE%E7%8E%87-%E7%B2%BE%E5%87%86%E7%8E%87-%E5%8F%AC%E5%9B%9E%E7%8E%87-f1-roc%E6%9B%B2%E7%BA%BF-auc%E6%9B%B2%E7%BA%BF-19b1ed9e9260.\n [5] 维基百科. ROC 曲线[EB/OL]([日期不详]). https://zh.wikipedia.org/zh-cn/ROC%E6%9B%B2%E7%BA%BF.\n [6] AZEVEDO C. On ROC and Precision-Recall curves[EB/OL]([日期不详]). https://towardsdatascience.com/on-roc-and-precision-recall-curves-c23e9b63820c.\n [7] GOOGLE. 分类 (Classification)：ROC 和曲线下面积[EB/OL]([日期不详]). https://developers.google.com/machine-learning/crash-course/classification/roc-and-auc?hl=zh-cn.\n [8] NEPTUNE.AI. F1 Score vs ROC AUC vs Accuracy vs PR AUC: Which Evaluation Metric Should You Choose?[EB/OL](2019–11–04). https://neptune.ai/blog/f1-score-accuracy-roc-auc-pr-auc#3.\n [9] WIKIPEDIA. Conditional entropy[EB/OL]([日期不详]). https://en.wikipedia.org/wiki/Conditional_entropy.\n [10] WIKIPEDIA. Cross entropy[EB/OL]([日期不详]). https://en.wikipedia.org/wiki/Cross_entropy.\n [11] 阿泽. 【机器学习】决策树（上）——ID3、C4.5、CART（非常详细）[EB/OL](2019–10–09). https://zhuanlan.zhihu.com/p/85731206.\n  目录  采样[1] 中位数 评估指标  精确率（Precision）  P@n  召回率（Recall） 准确率（Accuracy） \\(F_1\\) 真阳性率（TPR）[5] 伪阳性率（FPR）[5] ROC 与 Precision-Recall 曲线[6]  ROC 与 P-R 曲线的比较[6] AUC(Area Under the Curve)  AveP(Average Precision)[3] MAP(Mean Average Precision)  信息论  条件熵[9]  输出层  sigmoid  损失函数  交叉熵[10]  传统机器学习算法  决策树  ID3[11] C4.5 CART  随机森林 GBDT  损失函数 回归的学习步骤 特征重要性 局部特征的贡献  XGBoost  树的输出 树的损失函数 节点分裂的增益  LightGBM K means  背景 迭代步骤 初始化方法   参考文献   "}),a.add({id:44,href:'/note/%E5%B7%A5%E5%85%B7/format/',title:"格式",section:"工具",content:"json2toml pip3 install --user remarshal 目录  json2toml   "}),a.add({id:45,href:'/note/%E7%BC%96%E7%A8%8B/template/',title:"模板",section:"编程",content:"Jinja for 循环 {% for item in navigation %} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026quot;{{ item.href }}\u0026quot;\u0026gt;{{ item.caption }}\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; {% endfor %} Tera raw {% raw %} Hello {{ name }} {% endraw %} 目录  Jinja  for 循环  Tera  raw    "}),a.add({id:46,href:'/note/%E5%B7%A5%E5%85%B7/browser/',title:"浏览器",section:"工具",content:"Firefox Tridactyl 设置 主题 : set theme dark 搜索 : unbind \u0026lt;C-f\u0026gt; 快捷键  表 1: Tridactyl 快捷键  功能 快捷键    标签页：关闭 d  标签页：恢复上一个 u  标签页：跳转 b  标签页：创建 t     目录  Firefox  Tridactyl  设置 快捷键     "}),a.add({id:47,href:'/note/AI/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/',title:"深度学习",section:"AI",content:"Fine-tuning vs Feature Extraction[1]  图 1: Fine-tuning 与 Feature Extraction  参考文献 [1] LI Z, HOIEM D. Learning without forgetting[J]. IEEE transactions on pattern analysis and machine intelligence, 2017, 40(12): 2935–2947.\n  目录  Fine-tuning vs Feature Extraction[1] 参考文献   "}),a.add({id:48,href:'/note/CS/%E7%AE%97%E6%B3%95/',title:"算法",section:"CS",content:"数据结构的存储方式  表 1: 数据结构的存储方式  存储方式 特点 优点 缺点    数组 顺序存储 - 支持随机访问 - 扩容时间复杂度 O(N)    - 节约存储空间 - 插入和删除时间复杂度 O(N)  链表 链式存储 - 扩容时间复杂度 O(1) - 不支持随机访问    - 插入和删除时间复杂度 O(1) - 需要存储指针     数据结构的基本操作 任何数据结构的基本操作都是增删查改。不同数据结构的目的是在不同的应用场景，尽可能高效地增删查改。\n遍历数组 void traverse(int[] arr) {  for (int i = 0; i \u0026lt; arr.length; i++) {  // 迭代访问 arr[i]  } } 遍历链表 class ListNode {  int val;  ListNode next; }  void traverse(ListNode head) {  for (ListNode p = head; p != null; p = p.next) {  // 迭代访问 p.val  } }  void traverse(ListNode head) {  // 递归访问 head.val  traverse(head.next) } 遍历二叉树 class TreeNode {  int val;  TreeNode left, right; }  void traverse(TreeNode root) {  // 前序遍历  traverse(root.left)  // 中序遍历  traverse(root.right)  // 后序遍历 } 遍历 N 叉树 class TreeNode {  int val;  TreeNode[] children; }  void traverse(TreeNode root) {  for (TreeNode child : root.children) {  traverse(child);  } } 遍历图 用 visited 数组做标记。\n动态规划 62. 不同路径 int unique_path(int m, int n) {  // dp[i][j]: unique_path(i + 1, j + 1)  vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(m, vector\u0026lt;int\u0026gt;(n, 0));  for (auto j = 0; j \u0026lt; n; ++j) {  dp[0][j] = 1;  }  for (auto i = 0; i \u0026lt; m; ++i) {  dp[i][0] = 1;  }  for (auto i = 1; i \u0026lt; m; ++i) {  for (auto j = 1; j \u0026lt; n; ++j) {  dp[i][j] = dp[i - 1][j] + dp[i][j - 1];  }  }  return dp[m - 1][n - 1]; } 64. 最小路径和 int min_path_sum(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;grid) {  if (grid.size() == 0 || grid[0].size() == 0) {  return 0;  }  size_t m = grid.size(), n = grid[0].size();  // dp[i][j]: min_path_sum(grid[0:i + 1][0:j + 1])  vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(m, vector\u0026lt;int\u0026gt;(n, 0));  dp[0][0] = grid[0][0];  for (size_t j = 1; j \u0026lt; n; ++j) {  dp[0][j] = dp[0][j - 1] + grid[0][j];  }  for (size_t i = 1; i \u0026lt; m; ++i) {  dp[i][0] = dp[i - 1][0] + grid[i][0];  }  for (size_t i = 1; i \u0026lt; m; ++i) {  for (size_t j = 1; j \u0026lt; n; ++j) {  dp[i][j] = std::min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];  }  }  return dp[m - 1][n - 1]; } 状态压缩 int climb_stair(int n) {  // dp[i]: climb_stair(i)  vector\u0026lt;int\u0026gt; dp(n + 1, 0);  dp[0] = 1;  dp[1] = 1;  for (auto i = 2; i \u0026lt;= n; ++i) {  dp[i] = dp[i - 1] + dp[i - 2];  }  return dp[n]; } 压缩为：\nint climb_stair_v2(int n) {  int p0 = 0, p1 = 1, p2 = 1;  for (auto i = 1; i \u0026lt;= n; ++i) {  p2 = p1 + p0;  p0 = p1;  p1 = p2;  }  return p2; } 字符串状态模板  在子数组 array[0..i] 中，以 array[i] 结尾的目标子序列的长度是 dp[i] 在子数组 arr1[0..i] 和子数组 arr2[0..j] 中，目标子序列的长度为 dp[i][j] 在子数组 array[i..j] 中，目标子序列的长度为 dp[i][j]  回溯法 单词搜索 bool dfs(int i, int j, int k, vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;board, string \u0026amp;word,  vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; \u0026amp;visited) {  if (board[i][j] != word[k]) {  return false;  }   if (k == word.size() - 1) {  return true;  }   visited[i][j] = true;  bool result = false;  vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; directions{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};  for (auto direction : directions) {  int i1 = i + direction.first, j1 = j + direction.second;  if (i1 \u0026gt;= 0 \u0026amp;\u0026amp; i1 \u0026lt; board.size() \u0026amp;\u0026amp; j1 \u0026gt;= 0 \u0026amp;\u0026amp; j1 \u0026lt; board[0].size()) {  if (!visited[i1][j1]) {  auto flag = dfs(i1, j1, k + 1, board, word, visited);  if (flag) {  result = true;  break;  }  }  }  }  visited[i][j] = false;  return result; }  bool exist(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;board, string word) {  vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visited(board.size(),  vector\u0026lt;bool\u0026gt;(board[0].size(), false));  for (int i = 0; i \u0026lt; board.size(); ++i) {  for (int j = 0; j \u0026lt; board[0].size(); ++j) {  if (dfs(i, j, 0, board, word, visited)) {  return true;  }  }  }  return false; } BFS // 计算从起点 start 到终点 target 的最近距离 int BFS(Node start, Node target) {  queue\u0026lt;Node\u0026gt; q; // 核心数据结构  set\u0026lt;Node\u0026gt; visited; // 避免走回头路   q.push(start); // 将起点加入队列  visited.insert(start);  int step = 0; // 记录扩散的步数   while(q.size() \u0026gt; 0) {  int size0 = q.size();  for (int i = 0; i \u0026lt; size0; i++) {  Node cur = q.front();  q.pop();  if (cur == target) {  return step;  }  for (Node x : cur.adj()) {  if (visited.find(x) == visited.end()) {  q.push(x);  visited.insert(x);  }  }  }  step++;  } } 二分搜索 int binary_search(vector\u0026lt;int\u0026gt; \u0026amp;nums, int target) {  int left = 0;  int right = nums.size();  while (left \u0026lt; right) {  int mid = left + (right - left) / 2; // 防止溢出  if (nums[mid] == target) {  return mid;  } else if (nums[mid] \u0026lt; target) {  left = mid + 1;  } else {  right = mid;  }  }  return -1; } 滑动窗口 void sliding_window(string s, string t) {  unordered_map\u0026lt;char, int\u0026gt; need, window;  for (char c : t) need[c]++;  int left = 0, right = 0;  int valid = 0;  while (right \u0026lt; s.size()) {  // c 是将要移入窗口的字符  char c = s[right]  // 右移窗口  right++;  // 进行窗口内数据的一系列更新  // debug 信息  printf(\u0026quot;window: [%d, %d]\\n\u0026quot;, left, right);  // 判断左侧窗口是否要收缩  while (window needs shrink) {  // d 是将要移出窗口的字符  char d = s[left];  // 右移窗口  left++;  // 进行窗口内数据的一系列更新  }  } } 目录  数据结构的存储方式 数据结构的基本操作  遍历数组 遍历链表  遍历二叉树 遍历 N 叉树 遍历图   动态规划  62. 不同路径 64. 最小路径和 状态压缩 字符串状态模板  回溯法  单词搜索  BFS 二分搜索 滑动窗口   "}),a.add({id:49,href:'/note/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/',title:"线性代数",section:"数学",content:"术语 共轭转置[1] \\[(\\m{A}^*)_{ij} = (\\m{A}_{ji})^*\\qquad(1)\\]\n其中，若记 \\(\\m{A}_{ji} = a + bi\\)，则 \\((\\m{A}_{ji})^* = a - bi\\)。\n相似矩阵  同一个线性变换在不同基下的矩阵称为相似矩阵  正交矩阵[2] \\[\\T{\\m{Q}}\\m{Q} = \\m{Q}\\T{\\m{Q}} = \\m{I}\\qquad(2)\\]\n酉矩阵[2] \\[\\m{U}^*\\m{U} = \\m{U}\\m{U}^* = \\m{I}\\qquad(3)\\]\n正规矩阵 \\[\\m{A}^*\\m{A} = \\m{A}\\m{A}^*\\qquad(4)\\]\n当且仅当 \\(\\m{A} = \\m{U}\\m{\\Lambda}\\m{U}^*\\) 时，方阵 \\(\\m{A}\\) 是正规矩阵。其中， \\(\\m{U}\\) 是酉矩阵；\\(\\m{\\Lambda} = \\diag(\\lambda_1,\\dots,\\lambda_n)\\) 是对角阵； \\(\\m{U}\\) 的列向量是对应于特征值 \\(\\lambda_1,\\dots,\\lambda_n\\) 的特征向量。\n旋转矩阵[3] 旋转矩阵的集合：\n\\[ \\SO(n) = \\{\\m{R} \\in \\set{R}^{n\\times n} \\mid \\m{R}\\T{\\m{R}} = \\m{I}, \\det(\\m{R}) = 1\\} \\qquad(5)\\]\n外积[4] \\[\\v{u} \\otimes \\v{v} = \\v{u}\\T{\\v{v}}\\qquad(6)\\]\nSVD（奇异值分解） 对任意一个 \\(m\\times n\\) 的复矩阵 \\(M\\)，有 \\(\\m{M} = \\m{U}\\m{\\Sigma}\\m{V}^*\\)。其中，\n\\[\\m{M}\\m{M}^* = \\m{U}(\\m{\\Sigma}\\m{\\Sigma}^*)\\m{U}^*\\qquad(7)\\] \\[\\m{M}^*\\m{M} = \\m{V}(\\m{\\Sigma}^*\\m{\\Sigma})\\m{V}^*\\qquad(8)\\]\n\\(\\m{\\Sigma}\\) 为 \\(m\\times n\\) 维的对角阵，且元素按大小排列。\nPCA（主成分分析） SNR（信噪比） \\[\\SNR = \\frac{\\sigma^2_{\\mathrm{signal}}}{\\sigma^2_{\\mathrm{noise}}}\\qquad(9)\\]\n协方差矩阵 设 \\(\\m{X}\\) 为 \\(m\\times n\\) 维矩阵，其中，\\(m\\) 为特征数，\\(n\\) 为样本数，则协方差矩阵为：\n\\[\\m{C}_{\\m{X}} = \\frac{1}{n}\\m{X}\\T{\\m{X}}\\qquad(10)\\]\n 假设 \\(\\m{X}\\) 的所有行向量均值为 \\(0\\)。\n 问题定义 寻找矩阵 \\(\\m{P}\\)，使得 \\(\\m{C}_{\\m{Y}}\\) 为对角阵，且元素按大小排列。其中，\\(\\m{Y} = \\m{P}\\m{X}\\)。\n解：记 \\(\\m{X}\\) 的奇异值分解为 \\(\\m{X} = \\m{U}\\m{\\Sigma}\\T{\\m{V}}\\)，那么 \\(\\m{P} = \\T{\\m{U}}\\)。\n  主成分的方向是 \\(\\m{P}\\) 的行向量，即 \\(\\m{U}\\) 的列向量，即 \\(\\m{X}\\m{X}^*\\) 的特征向量 \\(\\m{Y} = \\m{\\Sigma}\\T{\\m{V}}\\)   参考文献 [1] WIKIPEDIA. Conjugate transpose[EB/OL]([日期不详]). https://en.wikipedia.org/wiki/Conjugate_transpose.\n [2] WIKIPEDIA. Orthogonal matrix[EB/OL]([日期不详]). https://en.wikipedia.org/wiki/Orthogonal_matrix.\n [3] 高翔. 视觉 SLAM 十四讲: 从理论到实践[M]. 电子工业出版社, 2017.\n [4] WIKIPEDIA. Outer product[EB/OL]([日期不详]). https://en.wikipedia.org/wiki/Outer_product.\n  目录  术语  共轭转置[1] 相似矩阵 正交矩阵[2] 酉矩阵[2] 正规矩阵 旋转矩阵[3] 外积[4]  SVD（奇异值分解） PCA（主成分分析）  SNR（信噪比） 协方差矩阵 问题定义  参考文献   "}),a.add({id:50,href:'/note/%E6%95%B0%E5%AD%A6/%E7%BB%9F%E8%AE%A1/',title:"统计",section:"数学",content:"中位数 先把 \\(x_1, x_2, \\dots, x_n\\) 从小到大排序，得到\n\\[x_{(1)}, x_{(2)}, \\dots, x_{(n)}\\]\n则中位数为：\n\\[ \\median(x) = \\begin{cases} x_{((n+1)/2)}, \u0026amp; n \\text{为奇数} \\\\ \\frac{1}{2}(x_{(n/2)} + x_{(n/2+1)}), \u0026amp; n \\text{为偶数} \\end{cases} \\qquad(1)\\]\n通用采样方法 逆变换采样 问题 已实现从均匀分布采样，如何从 \\(p(x)\\) 采样？\n步骤 记 \\(u\\) 为 \\(x\\) 的累积分布函数：\n\\[u = \\Phi(x) = \\int_{-\\infty}^x p(t)\\d t\\qquad(2)\\]\n那么按照以下步骤即可从 \\(p(x)\\) 采样：\n 从均匀分布 \\(U(0, 1)\\) 产生一个随机数 \\(u_i\\) 计算 \\(x_i = \\Phi^{-1}(u_i)\\)，得到的 \\(x_i\\) 服从 \\(p(x)\\) 分布  拒绝采样 问题 已实现从均匀分布、\\(q(x)\\) 采样，如何从 \\(\\pi(x)\\) 采样？\n步骤 选择 \\(M\\)，使得对于 \\(\\forall x, \\pi(x)\\le M q(x)\\) 从参考分布 \\(q(x)\\) 采样得 \\(x_i\\) 从均匀分布 \\(U(0, 1)\\) 产生一个随机数 \\(u_i\\) 如果 \\(u_i \u0026lt; \\frac{\\pi(x_i)}{M q(x_i)}\\)，则接受样本 \\(x_i\\)；否则拒绝，返回 2  证明 即证明 \\(p(x\\mid\\mathrm{accept}) = \\pi(x)\\)。\n\\[ \\begin{align} p(x, \\mathrm{accept}) \u0026amp;= q(x)p(\\mathrm{accept}\\mid x) \\\\ \u0026amp;= q(x)\\int_{U}p(u)p(\\mathrm{accept}\\mid x,u)\\d u \\\\ \u0026amp;= q(x)\\int_0^{\\frac{\\pi(x)}{M q(x)}}p(u)\\d u \\\\ \u0026amp;= \\frac{\\pi(x)}{M} \\end{align} \\qquad(3)\\]\n\\[ \\begin{align} p(\\mathrm{accept}) \u0026amp;= \\int_{X}p(x,\\mathrm{accept})\\d x \\\\ \u0026amp;= \\int_{X}\\frac{\\pi(x)}{M}\\d x \\\\ \u0026amp;= \\frac{1}{M} \\end{align} \\qquad(4)\\]\n由式. 3 和式. 4 可得，\n\\[ p(x\\mid\\mathrm{accept}) = \\frac{p(x,\\mathrm{accept})}{p(\\mathrm{accept})} = \\pi(x) \\qquad(5)\\]\n重要性采样 MCMC 采样 目录  中位数 通用采样方法  逆变换采样  问题 步骤  拒绝采样  问题 步骤 证明  重要性采样 MCMC 采样    "}),a.add({id:51,href:'/note/CS/encoding/',title:"编码",section:"CS",content:"GB2312、GBK 和 GB18030 的关系[1] GBK 兼容 GB2312，GB18030 兼容 GBK 与 GB2312。\n参考文献 [1] 知乎. GB2312、GBK、GB18030 这几种字符集的主要区别是什么？[EB/OL](2016–11–08). https://www.zhihu.com/question/19677619/answer/12616362.\n  目录  GB2312、GBK 和 GB18030 的关系[1] 参考文献   "}),a.add({id:52,href:'/note/%E5%B7%A5%E5%85%B7/%E7%BC%96%E8%BE%91%E5%99%A8/',title:"编辑器",section:"工具",content:"Visual Studio Code 插件  Visual Studio Code 插件  插件 ID 用途 依赖    xaver.clang-format 格式化   esbenp.prettier-vscode 格式化   fcrespo82.markdown-table-formatter 表格格式化   cheshirekow.cmake-format cmake 格式化 pip install cmake_format  streetsidesoftware.code-spell-checker 拼写检查   stkb.rewrap 断行   llvm-vs-code-extensions.vscode-clangd C、C++   ms-vscode.cmake-tools cmake     快捷键  Visual Studio Code 快捷键  快捷键 含义    Ctrl + P Go to File…  Ctrl + Shift + P Show All Commands  Alt + Q 断行    Vim 包管理器 安装 curl -fLo ~/.local/share/nvim/site/autoload/plug.vim --create-dirs \\  https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim 使用 :PlugInstall \u0026quot; 安装插件 :PlugUpdate \u0026quot; 升级插件 :PlugUpgrade \u0026quot; 升级 plug 安装依赖的二进制 rust rustup component add rls rust-analysis rust-src cmake pip install --user cmake_format coc :CocInstall coc-clangd :CocInstall coc-flutter :CocInstall coc-python :CocInstall coc-rls :CocInstall coc-yaml  表 1: lsp-server  编程语言 lsp-server    dhall dhall-lsp-server     打开文件 nvim $(fzf) 快捷键  表 2: Vim 快捷键  功能 快捷键    搜索：搜索文件并水平分割窗口打开 \u0026lt;Leader\u0026gt;f + Ctrl-x  Buffer：关闭 buffer \u0026lt;Leader\u0026gt;q  文件树：:NERDTreeFind \u0026lt;Leader\u0026gt;tf  文件树：:NERDTreeClose \u0026lt;Leader\u0026gt;tq  表格：:TableModeToggle \u0026lt;Leader\u0026gt;=  跳转：上一个位置 Ctrl-o  跳转：下一个位置 Ctrl-i  跳转：Go to definition gd  拼写检查：标记为 good word zg  拼写检查：更新二进制 zr       noremap 指 non-recursive map[1] map 指 recursive map[1] nmap 指 normal 模式下的 recursive map[1]   寄存器  表 3: Vim 寄存器  变量 含义    % 当前文件的路径  # 上一个文件的路径     Android Studio 字体 编辑器字体 File -\u0026gt; Settings -\u0026gt; Editor -\u0026gt; Font。\n菜单字体 File -\u0026gt; Settings -\u0026gt; Appearance \u0026amp; Behavior -\u0026gt; Appearance。\n[1] DRAI. What is the difference between the remap, noremap, nnoremap and vnoremap mapping commands in Vim?[EB/OL](2010–09–23). https://stackoverflow.com/a/3776182.\n  目录  Visual Studio Code  插件 快捷键  Vim  包管理器  安装 使用 安装依赖的二进制 coc  打开文件 快捷键 寄存器  Android Studio  字体  编辑器字体 菜单字体     "}),a.add({id:53,href:'/note/CS/network/',title:"网络",section:"CS",content:"iptables 列出 nat 规则 iptables -t nat -L 列出 prerouting 规则 sudo iptables -t nat -v -L PREROUTING -n --line-number 删除 prerouting 规则 sudo iptables -t nat -D PREROUTING \u0026lt;rule_number\u0026gt; 端口转发 iptables -A PREROUTING -t nat -i eth0 -p tcp --dport 80 -j REDIRECT --to-port 8080 目录  iptables  列出 nat 规则 列出 prerouting 规则 删除 prerouting 规则 端口转发    "}),a.add({id:54,href:'/note/%E8%A7%86%E8%A7%89/video/',title:"视频",section:"视觉",content:"ffmpeg 查看视频时长 ffmpeg -i {} 2\u0026gt;\u0026amp;1 | grep Duration 目录  ffmpeg  查看视频时长    "}),a.add({id:55,href:'/note/LeetCode/%E9%93%BE%E8%A1%A8/',title:"链表",section:"LeetCode",content:"148 链表排序 给你链表的头结点 head，请将其按升序排列并返回排序后的链表。\n自底向上归并排序  时间复杂度：\\(O(n\\log n)\\) 空间复杂度：\\(O(1)\\)  ListNode *merge(ListNode *h1, ListNode *h2) {  ListNode *dummy_head = new ListNode(0);  ListNode *p = dummy_head;  while (h1 \u0026amp;\u0026amp; h2) {  if (h1-\u0026gt;val \u0026lt;= h2-\u0026gt;val) {  p-\u0026gt;next = h1;  h1 = h1-\u0026gt;next;  } else {  p-\u0026gt;next = h2;  h2 = h2-\u0026gt;next;  }  p = p-\u0026gt;next;  }  if (h1) {  p-\u0026gt;next = h1;  } else if (h2) {  p-\u0026gt;next = h2;  }  auto h = dummy_head-\u0026gt;next;  delete dummy_head;  return h; }  ListNode *sort_list(ListNode *head) {  int n = 0;  ListNode *p = head;  while (p) {  n++;  p = p-\u0026gt;next;  }  ListNode *dummy_head = new ListNode(0, head);  for (int sub_size = 1; sub_size \u0026lt; n; sub_size \u0026lt;\u0026lt;= 1) {  ListNode *p0 = dummy_head;  p = dummy_head-\u0026gt;next;  while (p) {  ListNode *h1 = p;  for (int i = 1; i \u0026lt; sub_size \u0026amp;\u0026amp; p-\u0026gt;next; i++) {  p = p-\u0026gt;next;  }  ListNode *h2 = p-\u0026gt;next;  p-\u0026gt;next = nullptr;  p = h2;  for (int i = 1; i \u0026lt; sub_size \u0026amp;\u0026amp; p-\u0026gt;next; i++) {  p = p-\u0026gt;next;  }  ListNode *p2 = nullptr;  if (p) {  p2 = p-\u0026gt;next;  p-\u0026gt;next = nullptr;  }  p0-\u0026gt;next = merge(h1, h2);  while (p0-\u0026gt;next) {  p0 = p0-\u0026gt;next;  }  p = p2;  }  }  head = dummy_head-\u0026gt;next;  delete dummy_head;  return head; } 目录  148 链表排序  自底向上归并排序    "}),a.add({id:56,href:'/note/AI/%E9%A1%B9%E7%9B%AE/',title:"项目",section:"AI",content:"移动推荐比赛 题目 提供 2 万用户 30 天的移动端行为数据，具体行为包括“浏览”、“收藏”、“加购物车”和“购买”，预测用户第 31 天购买的商品。评价标准是 F1 Score。\n  F1 Score 是精确率和召回率的调和平均数 精确率指：你认为的正样本，有多少猜对了 召回率指：正样本有多少被找回来了   特征  时间型：  ui \u0026amp;\u0026amp; uc：  最近一次加购物车到现在多少小时 最近一次购买到现在多少小时 最近一次浏览到现在多少小时 最近一次收藏到现在多少小时 用户从浏览到购买经历多少小时   统计型：  ui \u0026amp;\u0026amp; uc：  用户对商品浏览多少次 用户对商品购买多少次 用户对商品加购物车多少次  i:  商品被购买了多少次    模型 GBDT 优点  防止过拟合（基分类器简单，通过拟合残差来减小偏差） 表达能力强 可解释性强，是发现特征组合的有效工具  类别型特征  Xgboost：One-Hot 编码，one vs rest LightGBM：直接支持，many vs many  word2vec  架构：三层神经网络，softmax 损失函数：条件概率，nll -\u0026gt; 简化成负采样  腾讯广告算法 题目 提供 91 天的广告点击历史记录，包含日期、用户信息（年龄、性别）、广告信息（广告 id、产品 id、产品类目 id、广告主 id、广告主行业 id）以及该用户当天点击该广告的次数，预测测试集中用户的年龄和性别。评分标准为年龄预测和性别预测的 accuracy 之和。\nBert  双向多层语言模型 Masked Language Model  随机选择 15% 的 token 80% 的概率 mask 10% 的概率替换单词 10% 的概率不变  是否是下一句 无监督的预训练 + fine-tuning  Transformer  输入：word embedding + positional encoding 输出：softmax Encoder-Decoder Encoder  multi-head attention + layer norm, residual feed forward + layer norm, residual  Decoder  Self-Attention: masked multi-head attention + layer norm, residual Encoder-Decoder Attention: multi-head attention + layer norm, residual feed forward + layer norm, residual   遮盖人脸 背景 基于离线采集的视频，重建高精度三维地图，用于 AR 导航。\n问题 定位技术比较稳定，在某商场的定位效果突然不好。经过仔细比较，发现人流的影响比较大。因此决定遮盖人脸。\n挑战  一开始效果不好，每帧图片只能找到一两张人脸 先做畸变校正，再检测 调整阈值 加入人体检测  最小二乘法对齐 背景 算法坐标系需要与导航坐标系、GT 坐标系对齐。\n问题  只用 2 个点对齐 -\u0026gt; 无法定量衡量误差 只能二维对齐  思路  综合考虑多个点 -\u0026gt; 最小二乘 统一三维与二维的对齐公式  挑战 在刚体变换约束下的最小二乘，找公式。\n基于 GPS 的点位筛选方案 背景 室外场景下定位容易飘，返回结果明显不正常。\n问题  基于 GPS 筛选，但 GPS 只有经纬度数据，而经纬度是球面坐标系  挑战 经纬度 -\u0026gt; 大地坐标系 -\u0026gt; 最小二乘对齐\nLAIN 背景  将不同技术栈的项目测试、打包、部署 应用的 cpu、内存资源管理，实例的水平扩容 应用的灰度发布和升级等  问题  用户友好的打包语言 -\u0026gt; travis ci/github workflows/gitlab pipeline 服务发现 网络通信（dns、calico）  Yi Push 背景 向手机 app 批量发送通知。\n问题  ios 基于回调的升级 nsq 消息队列，支持批量处理  目录  移动推荐比赛  题目 特征 模型  GBDT word2vec   腾讯广告算法  题目 Bert  Transformer   遮盖人脸  背景 问题 挑战  最小二乘法对齐  背景 问题 思路 挑战  基于 GPS 的点位筛选方案  背景 问题 挑战  LAIN  背景 问题  Yi Push  背景 问题    "}),a.add({id:57,href:'/note/%E5%B7%A5%E5%85%B7/project-management/',title:"项目管理",section:"工具",content:"confluence 新建子页面 创建页面 -\u0026gt; 创建页面。\n目录  confluence  新建子页面    "})}()